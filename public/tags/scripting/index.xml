<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Scripting on Hugo&#39;s Blog</title>
    <link>http://blog.slabnet.com/tags/scripting/</link>
    <description>Recent content in Scripting on Hugo&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>hugo@slabnet.com (Hugo Slabbert)</managingEditor>
    <webMaster>hugo@slabnet.com (Hugo Slabbert)</webMaster>
    <copyright>&amp;copy; 2016 Hugo Slabbert</copyright>
    <lastBuildDate>Wed, 13 Aug 2008 05:35:37 +0000</lastBuildDate>
    <atom:link href="http://blog.slabnet.com/tags/scripting/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Accessing Active Directory in PHP using ADLDAP</title>
      <link>http://blog.slabnet.com/post/accessing-active-directory-in-php-using-adldap/</link>
      <pubDate>Wed, 13 Aug 2008 05:35:37 +0000</pubDate>
      <author>hugo@slabnet.com (Hugo Slabbert)</author>
      <guid>http://blog.slabnet.com/post/accessing-active-directory-in-php-using-adldap/</guid>
      <description>&lt;p&gt;Lately, our company has started developing user web portals for our clients. The main goal is to provide a central reference point for common links (webmail, helpdesk, remote assistance links &amp;hellip; ), howto documents, and other files and resources. A secondary goal was to also allow user administrators to perform basic user management through a web interface. This would include things like disabling/creating/unlocking user accounts, resetting passwords, and modifying group memberships for access reasons. Myself and the other admin tasked with setting up this portal are most familiar with PHP, and so we went of looking for the best means of interfacing with Active Directory through PHP. &lt;!-- more --&gt;&lt;/p&gt;

&lt;p&gt;Now, you can obviously use PHP&amp;rsquo;s built-in LDAP support, provided PHP was built &amp;ndash;with-ldap. If you&amp;rsquo;re doing a lot of calls back and forth though, this can get pretty tedious pretty fast. It can also be quite intimidating to someone who is more of a sysadmin that a full-time developer (myself included!). So, abstracting away some of the complexity would be handy. I&amp;rsquo;m betting there are other systems out there, but for us, &lt;a href=&#34;http://adldap.sourceforge.net/&#34;&gt;adldap&lt;/a&gt; was the answer.&lt;/p&gt;

&lt;p&gt;Adldap provides an easy-to-use interface for both querying and modifying Active Directory. This post is not meant to be a complete setup guide, but rather just an overview, so here&amp;rsquo;s the quick summary:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Runs on Apache or IIS (although the documentation is a little thin on using IIS)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Might require some configuration in your environment to support secure LDAP queries over SSL&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Incorporates into your PHP pages through a class definition file. Configure the settings in the provided adldap.php file to match your environment, include() it in your php page, initialize an instance of the class (&lt;code&gt;$adldap = new adLDAP();&lt;/code&gt;), and you&amp;rsquo;re ready to go.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Allows you to add custom functions by adding to the class definition file.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If some of that sounds scary, don&amp;rsquo;t worry: It can sound more intimidating than it really is. If you have some reasonable PHP background, just go and check it out and get your feet wet. Like I said: Both myself and the other project contributor are not full-time developers, but we&amp;rsquo;ve thrown pretty useful AD integration into the portals. Heck, we&amp;rsquo;ve even started incorporating some AJAX on the site (with some help from &lt;a href=&#34;http://www.prototypejs.org/&#34;&gt;Prototype&lt;/a&gt;&amp;hellip;but that&amp;rsquo;s another post&amp;hellip;) to work with adldap and make the thing pretty slick overall!&lt;/p&gt;

&lt;p&gt;One thing that was getting at me a little bit was that I couldn&amp;rsquo;t just throw a custom ldap query string into aldap and get the results. Part of the abstraction is that you get a set of functions for querying for specific types of information: user_info(), user_delete(), authenticate(), group_create(), etc, but no raw ldap query function. So I checked out how the thing is put together, and I bastardized some of the existing functions to suit my purposes. If you&amp;rsquo;re familiar with ldap queries, add the following code into your aldap.php class definition file, and you&amp;rsquo;ve got yourself an easy way of performing custom ldap queries:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;function any_info($filter=NULL,$fields=NULL){
// Written by Hugo Slabbert (JustAnotherSysadmin - http://bamboo.slabnet.com/~hslabbert/blog) from other functions; defaults to root
if (!$this-&amp;gt;_bind){ return (false); }
if ( $filter==NULL ){ $filter=&amp;quot;(&amp;amp;(objectclass=domainDNS)(!(distinguishedname=&amp;quot; . $this-&amp;gt;_base_dn . &amp;quot;)))&amp;quot;; }
if ($fields==NULL){ $fields=array(&amp;quot;name&amp;quot;,&amp;quot;cn&amp;quot;,&amp;quot;displayname&amp;quot;,&amp;quot;dn&amp;quot;); }
$sr=ldap_search($this-&amp;gt;_conn,$this-&amp;gt;_base_dn,$filter,$fields);
$entries = ldap_get_entries($this-&amp;gt;_conn, $sr);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;return ($entries);
}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;If you do use the code snippet, I just ask that you keep the comments in tact. I don&amp;rsquo;t mind sharing, but I&amp;rsquo;d like a little bit of the credit!&lt;/p&gt;

&lt;p&gt;When you use the &lt;code&gt;any_info()&lt;/code&gt; function above, it takes two parameters: your ldap query (&lt;code&gt;$filter&lt;/code&gt;), and an array of which attributes you wish to return for the objects that match your query (&lt;code&gt;$fields&lt;/code&gt;). If you leave the second parameter blank, the default attributes of name, cn (canonical name), display name, and dn (distinguished name) will be returned.&lt;/p&gt;

&lt;p&gt;So, go ahead! Try it out! Let me know if it works for you and what doesn&amp;rsquo;t. I do have two final recommendations, though:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;If you run into technical difficulties getting adldap running properly, you&amp;rsquo;re probably better off going through their actual support (forums, documentation, etc.) than posting requests here. I&amp;rsquo;ve used the system, but I&amp;rsquo;m betting you will get way better support from the actual devs!&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Remember that the point of this tool is to enable access to your Active Directory through the a web interface. Secure your web app accordingly! Putting powerful tools on the web is great, but realize that you are doing just that: Putting POWERFUL tools on the web! You are the best judge (hopefully!) of what suits your organization.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Happy coding!&lt;/p&gt;

&lt;p&gt;Bitcoin tip address for this post: 13344S6vTAmrM5De7DermysvN6UE3QDSzb&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Find Disabled and Inactive User and Computer Accounts using Powershell - Part II</title>
      <link>http://blog.slabnet.com/post/find-disabled-and-inactive-user-and-computer-accounts-using-powershell-part2/</link>
      <pubDate>Tue, 25 Mar 2008 05:28:20 +0000</pubDate>
      <author>hugo@slabnet.com (Hugo Slabbert)</author>
      <guid>http://blog.slabnet.com/post/find-disabled-and-inactive-user-and-computer-accounts-using-powershell-part2/</guid>
      <description>&lt;p&gt;Part I demonstrated how to find aged or inactive accounts, and in Part II we will look at another lingering account type: disabled accounts.&lt;/p&gt;

&lt;p&gt;Like inactive accounts, Directory Searchers also come in handy for disabled accounts. We can also, however, read an Active Directory account&amp;rsquo;s status directly from a hidden attribute on the ADSI object. Let&amp;rsquo;s start with the Directory Searcher method. This entry also draws from &lt;a href=&#34;http://blogs.technet.com/bahramr/archive/2008/01/25/powershell-script-to-disable-inactive-accounts-in-active-directory.aspx&#34;&gt;Bahramâ€™s Blog&lt;/a&gt;. The code:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$adobjroot = [adsi]&#39;&#39;
$objdisabsearcher = New-Object System.DirectoryServices.DirectorySearcher($adobjroot)
$objdisabsearcher.filter = &amp;quot;(&amp;amp;(objectCategory=person)(objectClass=user)(userAccountControl:1.2.840.113556.1.4.803:=2))&amp;quot;
$resultdisabaccn = $objdisabsearcher.findall() | sort path&lt;/code&gt;&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;That was a lot easier! The &lt;code&gt;$adobjroot&lt;/code&gt; line gives us an ADSI object for the root of our domain. The second line creates a new Directory Services searcher, and then we add our filter.&lt;/p&gt;

&lt;p&gt;As with Part I, setting objectCategory to &lt;code&gt;person&lt;/code&gt; and objectClass to &lt;code&gt;user&lt;/code&gt; sets up our filter to search for user accounts; switch both of those to &lt;code&gt;computer&lt;/code&gt; to search for computer accounts instead.&lt;/p&gt;

&lt;p&gt;The userAccountControl portion is a bit of weird number, though, isn&amp;rsquo;t it?! After some digging, I was able to determine that the &lt;code&gt;:1.2.840.113556.1.4.803:&lt;/code&gt; is the attribute ID for the Last-Logon-Timestamp Attribute (found on an &lt;a href=&#34;http://msdn2.microsoft.com/en-us/library/ms676824.aspx&#34;&gt;MSDN article&lt;/a&gt; linked from &lt;a href=&#34;http://blogs.technet.com/bahramr/archive/2008/01/25/powershell-script-to-disable-inactive-accounts-in-active-directory.aspx&#34;&gt;Bahram&amp;rsquo;s Blog&lt;/a&gt;). Specifying that value in the directory searcher filter queries for the value of that specific attribute stored in the userAccountControl property, rather than userAccountControl as a whole. StephenÂ Looney actually corrected this for me, as I was somewhat off the mark in my deduction. The string is not a selection filter, as I had supposed, but more akin to a bitwise OR operator. See his comment below for clarification.&lt;/p&gt;

&lt;p&gt;The last line of the code simply collects our searcher results in System.DirectoryServices.SearchResult collection&lt;/p&gt;

&lt;p&gt;The alternative method to determine an account&amp;rsquo;s status is to check a hidden attribute on the ADSI object itself. For this you will need the Distinguished Name of a user or computer account:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$struserdn = &amp;quot;CN=Some User,OU=Users,OU=Corp,DC=yourdomain,DC=com&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Set up an ADSI object for that account:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$adobjuser = [ADSI]&amp;quot;LDAP://$struserdn&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;And access the hidden method:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$adobjuser.PsBase.InvokeGet(&amp;quot;AccountDisabled&amp;quot;)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;This will return $true if the account is disabled, and $false if the account is not disabled (i.e. it is enabled). It&amp;rsquo;s not as glamorous as the directory searcher method, but I think both have their place.&lt;/p&gt;

&lt;p&gt;Also, feel free to play around with the lastLogonTimeStamp and UserAccountControl attributes in the directory searcher. For instance, to find only disabled accounts that have been inactive for a certain number of days, you could use an LDAP string like:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$objsearcher.filter =&lt;/code&gt;&lt;code&gt;(&amp;amp;(objectCategory=person)(objectClass=user)(userAccountControl:1.2.840.113556.1.4.803:=2)&lt;/code&gt;&lt;code&gt;(lastLogonTimeStamp&amp;lt;=&amp;quot; + $lltIntLimit + &amp;quot;)&lt;/code&gt;&lt;code&gt;)&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Or switch it up for only enabled accounts inactive for a certain period by flipping the userAccountControl portion around be negative:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$objsearcher.filter =&lt;/code&gt;&lt;code&gt;(&amp;amp;(objectCategory=person)(objectClass=user)(!(userAccountControl:1.2.840.113556.1.4.803:=2)&lt;/code&gt;&lt;code&gt;)(lastLogonTimeStamp&amp;lt;=&amp;quot; + $lltIntLimit + &amp;quot;)&lt;/code&gt;&lt;code&gt;)&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;I hope this has been helpful. As always, comments, corrections, additions, or questions are appreciated.&lt;/p&gt;

&lt;p&gt;Bitcoin tip address for this post: 192yT6362K6BgLpm8B2xhcCVZtrnwQkjek&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Find Disabled and Inactive User and Computer Accounts using Powershell - Part I</title>
      <link>http://blog.slabnet.com/post/find-disabled-and-inactive-user-and-computer-accounts-using-powershell-part1/</link>
      <pubDate>Tue, 25 Mar 2008 05:28:15 +0000</pubDate>
      <author>hugo@slabnet.com (Hugo Slabbert)</author>
      <guid>http://blog.slabnet.com/post/find-disabled-and-inactive-user-and-computer-accounts-using-powershell-part1/</guid>
      <description>&lt;p&gt;We&amp;rsquo;ll start off with Inactive accounts first, and then work on the disabled accounts after that.&lt;/p&gt;

&lt;p&gt;Active Directory in Server 2003 has a nice user/computer attribute called lastLogonTimeStamp that can help us keep track of inactive accounts. If you have ever tried to use that attribute, however, you might have come up with something like this&amp;hellip;&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;&lt;code&gt;PoSH&amp;gt; $struserdn = &amp;quot;CN=Some User,OU=Users,OU=Corp,DC=yourdomain,DC=local&amp;quot;
PoSH&amp;gt; $adobjuser = [ADSI]&amp;quot;LDAP://$struserdn&amp;quot;
PoSH&amp;gt; $adobjuser
{CN=Some User,OU=Users,OU=Corp,DC=yourdomain,DC=local}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;PoSH&amp;gt; $adobjuser.lastLogonTimetamp&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;PoSH&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;What the &amp;hellip;? Hmm&amp;hellip;I&amp;rsquo;m sure I saw lastLogonTimestamp in the members for that object before:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;PoSH&amp;gt;$adobjuser | Get-Member&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;TypeName: System.DirectoryServices.DirectoryEntry
...
lastLogonTimestamp              Property   System.DirectoryServices.PropertyValueCollection lastLogonTimestamp {get;...
...
&lt;/code&gt;
&lt;code&gt;PoSH&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Right,  like I said! Then why doesn&amp;rsquo;t it give me any information for that property? May it&amp;rsquo;s blank? Highly unlikely, but let&amp;rsquo;s check:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;PoSH&amp;gt; $adobjuser | Format-List *
...
lastLogonTimestamp              : {System.__ComObject}
...&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;PoSH&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Great! What do I do with that thing? To be honest, working with ComObjects is not really my thing, but we still can get the information we want. For my purposes, I was searching through AD with a DirectorySearcher anyway, and the answer to my problems came from DirectorySearcher in the end. First, the code (credit to &lt;a href=&#34;http://blogs.technet.com/bahramr/archive/2008/01/25/powershell-script-to-disable-inactive-accounts-in-active-directory.aspx&#34;&gt;Bahram&amp;rsquo;s Blog&lt;/a&gt;), and then we&amp;rsquo;ll run through what we&amp;rsquo;re actually doing.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$currentDate = [System.DateTime]::Now
$currentDateUtc = $currentDate.ToUniversalTime()
&lt;/code&gt;&lt;code&gt;$lltstamplimit = $currentDateUtc.AddDays(- $NumDays)
$lltIntLimit = $lltstampLimit.ToFileTime()
$adobjroot = [adsi]&#39;&#39;
&lt;/code&gt;&lt;code&gt;$objstalesearcher = New-Object System.DirectoryServices.DirectorySearcher($adobjroot)
&lt;/code&gt;&lt;code&gt;$objstalesearcher.filter = &amp;quot;(&amp;amp;(objectCategory=person)(objectClass=user)(lastLogonTimeStamp&amp;lt;=&amp;quot; + $lltIntLimit + &amp;quot;))&amp;quot;
&lt;/code&gt;&lt;code&gt;$resultstaleaccn = $objstalesearcher.findall() | sort path&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Alright, so before we get going, this snippet of code requires that we define an Int32 variable called &lt;code&gt;$numdays&lt;/code&gt; before we run it. This will be used as the number of days since the account last logged on. So what exactly is going on here? The easiest way to both get a proper DateTime object and get a relative time for setting the period for inactive accounts is to get the current date and time:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$currentDate = [System.DateTime]::Now&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;As far as I can see, you could also use &lt;code&gt;$currentdate = Get-Time&lt;/code&gt; , so it&amp;rsquo;s your choice, really.&lt;/p&gt;

&lt;p&gt;Active Directory stores times in UTC format, so we can use the ToUniversalTime() method available on the System.DateTime class:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$currentDateUtc = $currentDate.ToUniversalTime()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;This is where the &lt;code&gt;$numdays&lt;/code&gt; variable comes in. Let&amp;rsquo;s say your organization has a policy in effect that accounts that have been inactive for 60 must be disabled. If the lastLogonTimeStamp attribute is 60 days less than the current Date/Time, then we know that account has not been logged onto for the last 60 days. So, we will want to search for accounts that have a value 60 days less than today in their lastLogonTimeStamp attribute. To make that reference point, we can do some simple math:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$lltstamplimit = $currentDateUtc.AddDays(- $NumDays)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;This assumes that we have run &lt;code&gt;$NumDays = 60&lt;/code&gt; somewhere before this last command, and effectively saves our last logon time stamp limit ($lltstamplimit) as a System.DateTime value 60 days before now.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$lltIntLimit = $lltstampLimit.ToFileTime()&lt;/code&gt; converts the &lt;code&gt;$lltstamplimit&lt;/code&gt; to an Int64 value. Why? You&amp;rsquo;ve got me! Please let me know if you have the goods on this, because I&amp;rsquo;m still blissfully unaware of the purpose/function of Int64 values.&lt;/p&gt;

&lt;p&gt;The rest is fairly straight-forward. We set up a directory searcher and define the filter as a user object the lastLogonTimeStamp less than the limit we defined in &lt;code&gt;$lltIntLimit&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$adobjroot = [adsi]&#39;&#39;
$objstalesearcher = New-Object System.DirectoryServices.DirectorySearcher($adobjroot)
$objstalesearcher.filter = &amp;quot;(&amp;amp;(objectCategory=person)(objectClass=user)(lastLogonTimeStamp&amp;lt;=&amp;quot; + $lltIntLimit + &amp;quot;))&amp;quot;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;In the name of tidiness and efficiency, I would recommend restricting the search root to your user containers with something like &lt;code&gt;$objstalesearcher.searchroot = &amp;quot;LDAP://$searchrootdn&amp;quot;&lt;/code&gt; where $searchrootdn is a distinguished name as a string.&lt;/p&gt;

&lt;p&gt;All that remains at that point is to collect the results:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$resultstaleaccn = $objstalesearcher.findall() | sort path&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;For my own purposes I sort the results by their LDAP path, but you obviously don&amp;rsquo;t have to. Remember that your result will be saved as a System.DirectoryServices.SearchResult object, so you will probably have to use &lt;code&gt;$_.Properties.[SomeProperty]&lt;/code&gt; to get the information you&amp;rsquo;re looking for.  From there, you can do with the results as you please.&lt;/p&gt;

&lt;p&gt;Oh, and if you&amp;rsquo;re looking for inactive computer  accounts instead of user accounts, switch both the objectCategory and objectClass values in your DS searcher filter to &lt;em&gt;computer.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;To learn how to find &lt;em&gt;disabled&lt;/em&gt; accounts rather than inactive ones, head over to Part II.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Bulk Rename Files with Sequential Index</title>
      <link>http://blog.slabnet.com/post/bulk-rename-files-with-sequential-index/</link>
      <pubDate>Sun, 23 Mar 2008 06:31:17 +0000</pubDate>
      <author>hugo@slabnet.com (Hugo Slabbert)</author>
      <guid>http://blog.slabnet.com/post/bulk-rename-files-with-sequential-index/</guid>
      <description>&lt;p&gt;I am pretty sure I&amp;rsquo;m not the only one who wants something more descriptive than DSC1900298.JPG to name my digital photos. And yes, I know that Windows Explorer allows you to rename pictures en masse, but I don&amp;rsquo;t like the convention they have chosen in that the first file is named &lt;em&gt;[common name].JPG&lt;/em&gt;, then the subsequent files are named &lt;em&gt;&lt;a href=&#34;2&#34;&gt;common name&lt;/a&gt;.JPG&lt;/em&gt; and so on and so forth.&lt;/p&gt;

&lt;p&gt;I had a few requirements for how I wanted to go about this:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Get rid of the parentheses. If I will be posting those pics online anywhere, I wanted to keep the names as free of special characters as I can.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Number the first file. The Windows Explorer route does not number the first file when doing bulk renames. This is easy enough to do manually, but I just don&amp;rsquo;t want to bother.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Keep a constant number of digits in the index number. I want the renaming process to take into account how many pictures there are and adjust the number of index digits accordingly. If there are fewer than 10 files/images, then only 1 digit is required (e.g. 1, 2, 3, 4&amp;hellip;9). If there are between 10 and 99 files (inclusive), then two digits are required (01, 02, 03&amp;hellip;10, 11, 12&amp;hellip;99). I think you get the idea. Windows definitely doesn&amp;rsquo;t do that.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;!-- more --&gt;I thought that Powershell would be the best tool for the job, but I still struggled a bit. I eventually found the following would do the trick:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$prefix = &amp;quot;[SomePrefix]&amp;quot;
$files = Get-ChildItem
$id = 1
$files | foreach { Rename-Item -Path $_.fullname&lt;/code&gt;&lt;code&gt;-NewName&lt;/code&gt;&lt;code&gt;( $prefix + ((($id++).tostring()).padleft(($files.count.tostring()).length) -replace &#39; &#39;,&#39;0&#39; ) + $_.extension) }&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Note that everything after the &lt;code&gt;$files |&lt;/code&gt;is all on one line of code, but it might appear in the post as being spread across multiple lines.&lt;/p&gt;

&lt;p&gt;The Explanation:&lt;/p&gt;

&lt;p&gt;The first line saves the contents of the current directory into an array. &lt;code&gt;$id = 1&lt;/code&gt; just resets our index counter so that the first file will be numbered 1. Now the fun stuff begins!&lt;/p&gt;

&lt;p&gt;We pipe the &lt;code&gt;$files&lt;/code&gt; array into a foreach loop to process through each of the files in the directory. The foreach loop just contains the Rename-Item cmdlet. We select the full path of the item passed through the pipeline, &lt;code&gt;$_.fullname&lt;/code&gt;, as the original item to rename. The -NewName item gets a bit complicated.&lt;/p&gt;

&lt;p&gt;As we will be including a whole bunch of items, we first open with parentheses, &amp;ldquo;(&amp;rdquo;. The new name will start with a string we have to define earlier, &lt;code&gt;$prefix&lt;/code&gt;. If, for instance, your collection of pictures in the working directory is from the slick cabling job you just did on one of your racks, you can set &lt;code&gt;$prefix = &amp;quot;SlickCablingJob&amp;quot;&lt;/code&gt;. This will result in files named something like &lt;code&gt;SlickCablingJob01.jpg&lt;/code&gt;, etc.&lt;/p&gt;

&lt;p&gt;The next portion has a few opening parentheses, and this is because we will be performing a bunch of operations on our &lt;code&gt;$id&lt;/code&gt; variable, which is our index number. We use &lt;code&gt;$id++&lt;/code&gt; because we want to &lt;code&gt;$id&lt;/code&gt; variable to increment each time we pass through the foreach loop and use the variable.&lt;/p&gt;

&lt;p&gt;To set the number of digits, I used the PadLeft() method. The PadLeft() method basically adds spaces to the left side of whatever string you are processing so that the resultant string is of a length that you specify. If, for instance, I have a string of &amp;ldquo;four&amp;rdquo; saved to the variable &lt;code&gt;$string&lt;/code&gt; and used the command $string.PadLeft(10), the resultant string would be &amp;ldquo;four&amp;rdquo; with 6 spaces to its left, for a total of 10 characters in our string.&lt;/p&gt;

&lt;p&gt;Unfortunately, PadLeft() is not a method of the Int32 class, of which our &lt;code&gt;$id&lt;/code&gt; variable is an instance, but it is a method of the String class. So, we first have to convert the &lt;code&gt;$id&lt;/code&gt; variable to a string using &lt;code&gt;$id.ToString()&lt;/code&gt;. I like to keep things clean, so I used &lt;code&gt;($id.ToString()).PadLeft()&lt;/code&gt; to first wrap up the result of &lt;code&gt;$id.ToString()&lt;/code&gt; and then apply the PadLeft() method.&lt;/p&gt;

&lt;p&gt;Now, PadLeft() requires an Int32 parameter to tell it how many places to pad to the left of the string. This is where some of the magic comes in. Remember how we saved the list of files in the directory to the array &lt;code&gt;$files&lt;/code&gt;? Well, that array has a property &lt;code&gt;Count&lt;/code&gt;, which is a count of the number of items in the array, in our case the number of files in the array.&lt;/p&gt;

&lt;p&gt;We count the number of items in our directory listing array using &lt;code&gt;$files.Count&lt;/code&gt;. Since we want to see how many characters are in the highest number in our file list (which is equal to the number of files in the &lt;code&gt;$files&lt;/code&gt; array), we can use the &lt;code&gt;Length&lt;/code&gt; property. The &lt;code&gt;Length&lt;/code&gt; property, when used on Strings, will return the number of characters in the string as an Int32 value. Using our &lt;code&gt;$string&lt;/code&gt; of &amp;ldquo;four&amp;rdquo; from earlier, &lt;code&gt;$string.Length&lt;/code&gt; will be equal to and Int32 value of 4, since there are four characters in the string &amp;ldquo;four&amp;rdquo;. If &lt;code&gt;$string&lt;/code&gt; were &amp;ldquo;one&amp;rdquo;, &lt;code&gt;$string.Length&lt;/code&gt; would be 3, since there are three characters in the string &amp;ldquo;one&amp;rdquo;. This can get confusing, so you might want to try it out with a few different values to get the hang of it.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s say that we have 45 files in our directory. &lt;code&gt;$files.Count&lt;/code&gt;would be an Int32 value of 45. The length property cannot be applied to Int32 values, so we have to convert our value to a string using &lt;code&gt;$files.Count.ToString()&lt;/code&gt;. In our example of 45 files in our directory, &lt;code&gt;$files.Count.ToString()&lt;/code&gt; would return a string value of &amp;ldquo;45&amp;rdquo;. The length property of that value would be the Int32 value 2. This is because the string &amp;ldquo;45&amp;rdquo; has two characters in it. If we had between 1 and 9 files (inclusive), the &lt;code&gt;$files.Count.ToString()&lt;/code&gt; value would be 1 because there is only one character in the numbers 1, 2, 3, 4, 5, 6, 7, 8, and 9 since they are single-digit numbers. If we had between 10 and 99 files in our list, we would have a double-digit number, and hence &lt;code&gt;$files.Count.ToString()&lt;/code&gt; would have a value of 2. Again, you might want to play around with this if you are unfamiliar with the concept.&lt;/p&gt;

&lt;p&gt;So far, then, we have &lt;em&gt;(($id++).ToString()).PadLeft(($Files.Count.ToString()).Length&lt;/em&gt;, which takes the index number, converts it to a string, and then pads it with spaces to its left so that the total of characters is equal to the number of characters in the count of the number of files in the list. It might be best to demonstrate with another example to bring it all together. Let&amp;rsquo;s say that we have one hundred (100) files that we are renaming, and the foreach loop is working through the first file.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;$id&lt;/code&gt; variable is set to the Int32 value of 1. This is converted to a string that reads &amp;ldquo;1&amp;rdquo;. Since we have 100 files in our list, &lt;code&gt;$files.Count&lt;/code&gt; will have an Int32 value of 100. In order to count the number of characters in that value, we convert it to a string using &lt;code&gt;$files.Count.ToString()&lt;/code&gt;, then count the number of characters using &lt;code&gt;$files.Count.ToString().Length&lt;/code&gt;. This gives us an Int32 value of 3, since there are three characters in the number 100. PadLeft() then pads our &lt;code&gt;$id&lt;/code&gt; of 1 so that it has three characters in total, as a one with 2 spaces to its left. We&amp;rsquo;re almost there!&lt;/p&gt;

&lt;p&gt;The last part of the indexing replaces the spaces from PadLeft() to zeroes, so that the files will show up chronologically in a directory listing. This is done through the &lt;code&gt;-replace &#39; &#39;,&#39;0&#39;&lt;/code&gt; part of the line, which replaces spaces with zeroes. For our example, we would no longer have &amp;ldquo; 1&amp;rdquo; but rather &amp;ldquo;001&amp;rdquo; (insert 007 joke here). Finally, my third requirement is met!&lt;/p&gt;

&lt;p&gt;All that is left to then append the original file extension to the filename. Since we have the original file in the pipeline, we can access its extension using &lt;code&gt;$_.Extension&lt;/code&gt;. And voila! We have our bulk rename tool!&lt;/p&gt;

&lt;p&gt;Now, as the code stands, we have to first define our &lt;code&gt;$prefix&lt;/code&gt; variable before using it, and it only acts on files in the current working directory. I threw this into a function with a parameter of &lt;code&gt;$prefix&lt;/code&gt;, so that I can easily define the prefix and call the function conveniently from within the directory that contains the files I want to rename. You could also specify an additional parameter of &lt;code&gt;$directory&lt;/code&gt; to the function to be able to work on directories other than your current working directory, as long as you change &lt;code&gt;$files = Get-ChildItem $directory&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Here is the function as it sits in my current Powershell profile:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;function Rename-Bulk($prefix)
{
$files = Get-ChildItem
$id = 1
$files | foreach { Rename-Item -Path $_.fullname&lt;/code&gt;&lt;code&gt;-NewName&lt;/code&gt;&lt;code&gt;( $prefix + ((($id++).tostring()).padleft(($files.count.tostring()).length) -replace &#39; &#39;,&#39;0&#39; ) + $_.extension) }
}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;To define the function in your Powershell session, either paste the code above at the Powershell prompt, or paste it into your Powershell profile to have it available each time you start Powershell (be sure to remove any line breaks; remember that everything after &lt;code&gt;$files |&lt;/code&gt; is one one line)!&lt;/p&gt;

&lt;p&gt;To add the extension I had mentioned to specify a directory other than your current working directory, use the following instead:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;function Rename-Bulk($prefix,$directory=$pwd)
{
$files = Get-ChildItem $directory
$id = 1
$files | foreach { Rename-Item -Path $_.fullname -NewName ( $prefix + ((($id++).tostring()).padleft(($files.count.tostring()).length) -replace &#39; &#39;,&#39;0&#39; ) + $_.extension) }
}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;That will select the current working directory by default if the second parameter is not specified, while still giving you the option to specify an alternate directory.&lt;/p&gt;

&lt;p&gt;As always, if there is something I&amp;rsquo;ve missed (it&amp;rsquo;s getting late!) or if you have something to add, please let me know.&lt;/p&gt;

&lt;p&gt;Bitcoin tip address for this post: 1M4ydWcEPsUXWrQYN254UrfkAbVGBbpZB8&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Take ownership of files and folders through script</title>
      <link>http://blog.slabnet.com/post/take-ownership-of-files-and-folders-through-script/</link>
      <pubDate>Sun, 23 Mar 2008 04:41:48 +0000</pubDate>
      <author>hugo@slabnet.com (Hugo Slabbert)</author>
      <guid>http://blog.slabnet.com/post/take-ownership-of-files-and-folders-through-script/</guid>
      <description>&lt;p&gt;As part of our process to disable user accounts, we take ownership of the user&amp;rsquo;s server-stored documents such as roaming profiles and redirected My Documents directories. We then either keep access restricted to the domain admins group or grant access to a replacement user who should receive access to the departed user&amp;rsquo;s files.&lt;/p&gt;

&lt;p&gt;With an upgrade to Exchange 2007, we have taken advantage of the Powershell access to Exchange objects, and have scripted the mailbox provisioning and account disable processes. One of the sticking points in getting the disable script wrapped up was seizing control of the user&amp;rsquo;s directories. Now, Powershell does have the ability to modify ACL&amp;rsquo;s through the New-Acl and Set-Acl cmdlets (links below), but the users have exclusive access to their server-side directories. It is easy enough to take ownership of a directory through the Windows Explorer Security dialog, but the Powershell methods all presented some form of error when trying to set permissions or change ownership on a file system object to which you do not already have access to.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;I struggled for some time off and on to try to work around this with a native Powershell way of seizing control of a directory, but I simply could not find what I was looking for. Eventually, I fell back to a simple tool built into Server 2003 already: Takeown.exe. Through a simple line, takeown got me the results I wanted. I built an array of strings for the directories I wanted to take ownership of, generally in a UNC path such as \servername\users$[sAMAccountName], then wrapped the takeown line in a Foreach loop:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Foreach ( $directory in $directories )
{
takeown.exe /A /R /D Y /F $directory
}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;To learn more about the options for Takeown, simply type Takeown /? at the command line. For reference:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;/A - Grants ownership to the Administrators group rather than a particular user.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;/R - Recurses&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;/D Y - Sets the default to prompts to &lt;em&gt;Yes&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;/F - The file name of the file system object to take ownership of&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;After taking ownership, the regular Powershell native cmdlets can be used to set up permissions as are required. For more information on Powershell ACL tools, check out the following links:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://mshforfun.blogspot.com/2005/12/play-with-acl-in-msh.html&#34;&gt;Play with ACL in MSH&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://blog.netnerds.net/2007/07/powershell-set-acl-does-not-appear-to-work/&#34;&gt;PowerShell: Set-Acl Does Not Appear to Work&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://richardsiddaway.spaces.live.com/Blog/cns!43CFA46A74CF3E96!1069.entry&#34;&gt;File system: Allow inheritable permissions from parent to propagate&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Bitcoin tip address for this post: 1MBiHN2jptsRRxYMvjypHH94JhQTv2QGyA&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Exchange 2007 Mailbox GUID </title>
      <link>http://blog.slabnet.com/post/exchange-2007-mailbox-guid/</link>
      <pubDate>Wed, 23 Jan 2008 05:46:35 +0000</pubDate>
      <author>hugo@slabnet.com (Hugo Slabbert)</author>
      <guid>http://blog.slabnet.com/post/exchange-2007-mailbox-guid/</guid>
      <description>&lt;p&gt;On a recent Exchange 2003 to 2007 upgrade, I ran into a very frustrating issue that significantly delayed our deployment. All new mailboxes that were created on using Exchange 2007 tools (Exchange 2007 Management Console or Powershell) were missing several crucial ADSI attributes, namely:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;legacyExchangeDN&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;msExchALObjectVersion&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;msExchMailboxGuid&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;msExchMailboxSecurityDescriptor (set to &amp;ldquo;not set&amp;rdquo;, all other accounts have a blank value here)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;msExchUserAccountControl&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;!-- more --&gt;Of these, the most important seem to be msExchMailboxGuid and msExchMailboxSecurityDescriptor. Without msExchMailboxGuid set, the user account effectively does not have a mailbox. We were desperate enough at one point to create a random mailbox GUID (ensuring first that it is not present anywhere else in the Exchange organization), but the msExchMailboxSecurityDescriptor not being set still ensured that the mailbox was inaccessible.&lt;/p&gt;

&lt;p&gt;After a few hours on the phone with MS support, and apparently some contact with a member of the Exchange 2007 development team, we were informed that this was due to a problem with the Exchange System Attendant and something to do with logs&amp;hellip;to be honest I was not able to completely understand the guy at this point.&lt;/p&gt;

&lt;p&gt;Anyhow, the temporary solution was to restart the System Attendant service on the mailbox server that is experiencing the problem. This is easy enough with Powershell (Restart-Service MSExchangeSA), but we ended up making use of the PsTools suite&amp;rsquo;s psservice because we had multiple mailbox servers going and we needed to sometimes restart the service on a remote mailbox server. Fortunately, restarting the System Attendant service in Exchange 2007 does not restart the Information Store, as was the case with Exchange 2003. After this, the proper attributes will again be stamped and user mailbox provisioning should be successful.&lt;/p&gt;

&lt;p&gt;The bug was apparently set to be resolved in SP1 for Exchange 2007 (released late last year), but I have not confirmed this.&lt;/p&gt;

&lt;p&gt;Check out these links for more info:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://episteme.arstechnica.com/eve/forums?a=tpc&amp;amp;s=50009562&amp;amp;f=12009443&amp;amp;m=362006418831&amp;amp;r=606003038831#606003038831&#34;&gt;Arstechnica Forum Thread&lt;/a&gt;
&lt;a href=&#34;http://forums.msexchange.org/m_1800455217/mpage_1/key_/tm.htm#1800455222&#34;&gt;MSExchange Forums Thread
&lt;/a&gt;&lt;a href=&#34;http://forums.microsoft.com/TechNet/ShowPost.aspx?PostID=2020465&amp;amp;SiteID=17&amp;amp;pageid=0&#34;&gt;Microsoft Forums (I)&lt;/a&gt;
&lt;a href=&#34;http://forums.microsoft.com/technet/ShowPost.aspx?postid=2343802&amp;amp;siteid=17&#34;&gt;Microsoft Forums (II)&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Modifying Group Memberships with Powershell, Part II</title>
      <link>http://blog.slabnet.com/post/modifying-group-memberships-with-powershell-part-2/</link>
      <pubDate>Sat, 19 Jan 2008 23:30:35 +0000</pubDate>
      <author>hugo@slabnet.com (Hugo Slabbert)</author>
      <guid>http://blog.slabnet.com/post/modifying-group-memberships-with-powershell-part-2/</guid>
      <description>&lt;p&gt;I had hoped to put this all in one post, but the thing would have gone on forever! Part I covered some basics in copying group memberships to an Active Directory user from another user, such as a template account, using Powershell. Part II will delve into my misadventures in gaining more control of user group memberships, including removing users from a group either by editing the group&amp;rsquo;s attributes or editing the user&amp;rsquo;s attributes. I was also looking for a way to change dial-in permissions on user accounts, and that will be covered by a similar strategy.&lt;/p&gt;

&lt;p&gt;While these examples should be less dependent on the MS Exchange 2007 snap-in for Powershell and &lt;a href=&#34;http://www.codeplex.com/PowerShellCX&#34;&gt;Powershell Community Extensions&lt;/a&gt;, please note that I have not checked through the code samples to confirm what is purely Powershell and what requires those snap-ins.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;So in Part I we did the following to add a user to a group:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Connected to the ADSI object for our group using &lt;code&gt;[adsi]&amp;quot;LDAP://[group&#39;s distinguished name]&amp;quot;&lt;/code&gt; and stored as &lt;em&gt;$fqgroup&lt;/em&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Added the user to the group using &lt;code&gt;$fqgroup.member.add(&amp;quot;[user&#39;s distinguished name]&amp;quot;)&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Applied the changes user &lt;code&gt;$fqgroup.setinfo()&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The problem for me came when I tried to remove group memberships. I don&amp;rsquo;t have a huge scripting background; I mostly dabble in batches, and PHP, and have avoided VBS whenever I can. Powershell is my first real foray into extensive automation, and I try to keep things simple where I can and use provided cmdlets, snap-ins, and wrappers. So, when I wanted to remove group memberships, I checked out what the Exchange 2007 snap-in for Powershell had to offer.&lt;/p&gt;

&lt;p&gt;Wouldn&amp;rsquo;t you know it? Exchange has some membership-manipulating options available for us:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Get-Group &#39;Test Group&#39; | Get-Member | Where-Object { $_.name -match &#39;members&#39; } | Format-List Name,Membertype,Definition&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;returns:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Name : get_Members
MemberType : Method
Definition : Microsoft.Exchange.Data.MultiValuedProperty&lt;/code&gt;1[[Microsoft.Exchange.
Data.Directory.ADObjectId, Microsoft.Exchange.Data.Directory, Version=8.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]] get_Members()
&lt;code&gt;
Name : set_Members
MemberType : Method
Definition : System.Void set_Members(MultiValuedProperty`1 value)
&lt;/code&gt;
Name : Members
MemberType : Property
Definition : Microsoft.Exchange.Data.MultiValuedProperty&lt;code&gt;1[[Microsoft.Exchange.
Data.Directory.ADObjectId, Microsoft.Exchange.Data.Directory, Version=8.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]] Members {get;set;}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;The only reasons I threw in the &lt;em&gt;Where-Object&lt;/em&gt; and &lt;em&gt;Format-List&lt;/em&gt; cmdlets were because I didn&amp;rsquo;t want to show every single member, and Powershell will by default output &lt;em&gt;Get-Member&lt;/em&gt; to a table and cut off the &lt;em&gt;Definition&lt;/em&gt; column that I&amp;rsquo;m interested in here.&lt;/p&gt;

&lt;p&gt;Now, notice that the property &lt;em&gt;Members** **&lt;/em&gt;(the last one in our list) specifically states {get;set;} at the end of its definition. This tells us that we should be able to both retrieve the members property (get) and make changes to it (set). Conveniently, we also have two methods for those tasks: _get&lt;em&gt;Members&lt;/em&gt; for retrieving the &lt;em&gt;Members&lt;/em&gt; property and _set&lt;em&gt;Members&lt;/em&gt; for making changes to it. It&amp;rsquo;s weird, though, that the definition for _get&lt;em&gt;Members&lt;/em&gt; has a whole bunch of .Net information about Exchange going on in there, while _set&lt;em&gt;Members&lt;/em&gt; simply references &lt;em&gt;System.Void&lt;/em&gt;, isn&amp;rsquo;t it? It&amp;rsquo;s also a little weird that the &lt;em&gt;Set-Group&lt;/em&gt; cmdlet doesn&amp;rsquo;t seem to have any options that reference membership (check &lt;code&gt;Get-Help Get-Group -detailed&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s try it, though:&lt;/p&gt;

&lt;p&gt;Using Active Directory Users and Computers (ADUC), create a new security group called &lt;em&gt;Powershell TestGroup&lt;/em&gt;, and add some users to it. I will use the example of User1 and User2. Then try the following code:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$group = Get-Group &#39;Powershell TestGroup&#39;
$group.Members&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;This should display a list of your group members showing their Rdn, Parent, Depth, DistinguishedName, DomainId, ObjectGuid, and Name properties. Good so far; let&amp;rsquo;s try the get_Members method:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$group.get_Members()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Still good right? You get the same list. Alright, now let&amp;rsquo;s save a new list of users that doesn&amp;rsquo;t include User1, and then to our _set&lt;em&gt;Members&lt;/em&gt; method:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$newgroupmembers = $group.get_Members() | Where-Object { $_.name -notmatch &amp;quot;User1&amp;quot; }&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;$newmembers will now include all of the group members except for User1. You can verify this by just typing &lt;code&gt;$newgroupmembers | Sort | Format-Table Name&lt;/code&gt; at the console. Alright, so we have our new list of users. Remember that we didn&amp;rsquo;t make the array $newmembers up ourselves but got the list using the get_Members() method, so we&amp;rsquo;re free of syntax errors here. Let&amp;rsquo;s try _set&lt;em&gt;Members&lt;/em&gt; then:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$group.set_Members($newgroupmembers)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Hmm&amp;hellip;that didn&amp;rsquo;t go so well. All of sudden Powershell gives us a bunch of error output:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Cannot convert argument &amp;quot;0&amp;quot;, with value: &amp;quot;System.Object[]&amp;quot;, for &amp;quot;set_Members&amp;quot; to type &amp;quot;Microsoft.Exchange.Data.MultiValuedProperty&lt;/code&gt;1[Microsoft.Exchange.Data.Directory.ADObjectId]&amp;rdquo;: &amp;ldquo;Cannot convert value &amp;ldquo;System.Object[]&amp;rdquo; to type &amp;ldquo;Microsoft.Exchange.Data.MultiValuedProperty&lt;code&gt;1[Microsoft.Exchange.Data.Directory.ADObjectId]&amp;quot;. Error: &amp;quot;Conversion from System.Management.Automation.PSObject to Microsoft.Exchange.Data.Directory.ADObjectId has not been implemented.&amp;quot;&amp;quot;t line:1 char:19
+ $group.set_members( &amp;lt;&amp;lt;&amp;lt;&amp;lt; $newgroupmembers)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Take note of the second to last line:&lt;/p&gt;

&lt;blockquote&gt;Conversion from System.Management.Automation.PSObject to Microsoft.Exchange.Data.Directory.ADObjectId has not been implemented.&lt;/blockquote&gt;

&lt;p&gt;Now, I&amp;rsquo;m not a .Net developer and I don&amp;rsquo;t claim to be _nearly _as intimately familiar with Powershell as some of the other guys out there (&lt;a href=&#34;http://thepowershellguy.com/blogs/posh/&#34;&gt;The Powershell Guy&lt;/a&gt; for instance), but this seems to be one of those little things that the Exchange team just didn&amp;rsquo;t get around to implementing. Maybe I&amp;rsquo;m wrong, I don&amp;rsquo;t know. But I do know that I needed a way around this road block.&lt;/p&gt;

&lt;p&gt;So, off I went through the wild, wild web, looking for people much smarter than myself who might be able to get this thing up and running. I have to give credit to these folks, and you might be able to get more useful information from them, so I will include links to other useful articles/blogs below. Keeping right on though, here&amp;rsquo;s what we need to do:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
$group = Get-Group &amp;quot;Powershell TestGroup&amp;quot;
$username = &amp;quot;User1&amp;quot;
$user = get-user $username
$userdn = $user.distinguishedName
$newgroupmembers = $group.members | Where-Object { $_.name -notmatch &amp;quot;$username&amp;quot; }
$groupdn = $group.distinguishedName
$fqgroup = [adsi]&amp;quot;LDAP://$groupdn&amp;quot;
$fqgroup.Member.Remove($userdn)
$fqgroup.setInfo()
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;After all that searching and tests, it was actually pretty simple! Here&amp;rsquo;s what we did:&lt;/p&gt;

&lt;p&gt;I did cheat a bit (like I said, I like to keep things simple when I can) and used the Exchange &lt;em&gt;Get-Group&lt;/em&gt; cmdlet for our $group variable, and I also used the Exchange &lt;em&gt;Get-User&lt;/em&gt; cmdlet for our $user variable, but you could use DirectoryServices.DirectorySearcher instead as in &lt;a href=&#34;http://janssenjones.typepad.com/janssenjonescom/2007/01/powershell_and_.html&#34;&gt;this post&lt;/a&gt;. I borrowed some of my info from that post as well, so credit is owed there. But I digress.&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;$newgroupmembers&lt;/em&gt; line is similar to the one we used earlier with our _set&lt;em&gt;Members&lt;/em&gt; example that failed. You can use either $group.members or $group.get_Members() interchangeably. All we&amp;rsquo;re doing is creating an array of group members that does not contain the user that we want to remove from the group.&lt;/p&gt;

&lt;p&gt;With &lt;em&gt;$fqgroup&lt;/em&gt; we are again just connecting to the group using the Powershell ADSI wrapper. In the end, all that needs to be done here is to use the &lt;em&gt;remove()&lt;/em&gt; method of the Member property of our &lt;em&gt;$fqgroup&lt;/em&gt;. The change is then applied using &lt;em&gt;setinfo().&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Now, remember how we found that methods weren&amp;rsquo;t displayed through Get-Member for ADSI objects? Try this one out for size:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$fqgroup.member | Get-Member&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Here we see methods available! But for &lt;code&gt;$fqgroup.member | Get-Member&lt;/code&gt;? Nope, nothing! Weird&amp;hellip;&lt;/p&gt;

&lt;p&gt;You should also theoretically be able to modify the user account directly and change the &lt;em&gt;memberOf&lt;/em&gt; attribute, but I have had some difficulty with this. I will update the post if I figure out what the problem was there.&lt;/p&gt;

&lt;p&gt;Anyway, there you have it. I owe a tremendous amount of thanks to several other IT bloggers for being able to post this:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://blogs.technet.com/benp/archive/2007/03/05/benp-s-basic-guide-to-managing-active-directory-objects-with-powershell.aspx&#34;&gt;Benpâ€™s Basic Guide to Managing Active Directory Objects with PowerShell&lt;/a&gt;
&lt;a href=&#34;http://www.viveksharma.com/techlog/2006/10/22/how-to-get-dl-membership-in-exchange-2007/&#34;&gt;How to get DL membership in Exchange 2007
&lt;/a&gt;&lt;a href=&#34;http://www.leadfollowmove.com/archives/powershell/managing-group-membership-in-active-directory-with-powershell-part-1&#34;&gt;Managing group membership in Active Directory with PowerShell (Part 1)
&lt;/a&gt;&lt;a href=&#34;http://www.leadfollowmove.com/archives/powershell/managing-group-membership-in-active-directory-with-powershell-part-2&#34;&gt;Managing group membership in Active Directory with PowerShell (Part 2)&lt;/a&gt;
&lt;a href=&#34;http://janssenjones.typepad.com/janssenjonescom/2007/01/powershell_and_.html&#34;&gt;Powershell and ActiveDirectory - Modify-Group-Membership
&lt;/a&gt;&lt;a href=&#34;http://richardsiddaway.spaces.live.com/blog/cns!43CFA46A74CF3E96!241.entry&#34;&gt;PowerShell script to list user group membership in Active Directory
Accessing AD with PowerShell&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Bitcoin tip address for this post: 1DMybxZn2eUfKndJsn56Xq7BUoZSFvFfeb&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Modifying Group Memberships with Powershell, Part I</title>
      <link>http://blog.slabnet.com/post/modifying-group-memberships-with-powershell-part-1/</link>
      <pubDate>Sat, 19 Jan 2008 19:03:40 +0000</pubDate>
      <author>hugo@slabnet.com (Hugo Slabbert)</author>
      <guid>http://blog.slabnet.com/post/modifying-group-memberships-with-powershell-part-1/</guid>
      <description>

&lt;p&gt;I recently had to spend &lt;em&gt;hours&lt;/em&gt; figuring out how to properly modify Active Directory group memberships using Powershell. Some of the .Net methods have not yet been implemented, so I had to get a bit tricky with it. I could find the various bits of information I needed in various places, so I hope that collecting them here in one place is of some use to others.&lt;/p&gt;

&lt;p&gt;The scenario was that I needed to disable user accounts in a Windows Server 2003 Active Directory environment running with Exchange 2007. We have a fairly customized, hosted Exchange environment, and so disabling a user is not just a simple matter and right-clicking and disabling the account in Active Directory Users and Computers (ADUC); we have a 2-page doc for the process to catch everything from removing group memberships to setting up email forwarding or restrictions, changing dial-in permissions, changing NTFS permissions on profile directories, etc.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;Anyway, I had already dabbled in modifying group memberships in our user creation script (still a bit clunky, but it gets the job done) by copying group memberships from a template account. It goes something like this (please note that several of these commands require the Exchange 2007 snap-in for Powershell, and some also the &lt;a href=&#34;http://www.codeplex.com/PowerShellCX&#34;&gt;Powershell Community Extensions&lt;/a&gt;  snap-in):&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
$templaccn = Get-Mailbox | Where-Object { $_.name -match [template account name] }
$newuser = Get-User [new user name]
$filterid = ( Get-User $templaccn.name ).identity
$groups = Get-Group -filter { Members -eq $filterid }
$groups | Foreach-Object {
$groupdn = $_.DistinguishedName
&lt;/code&gt;&lt;code&gt;$fqgroup = [ADSI](&amp;quot;LDAP://$groupdn&amp;quot;)
&lt;/code&gt;&lt;code&gt;$membercheck = ($fqgroup.member | Where-Object { $_ -eq $newuser})
&lt;/code&gt;&lt;code&gt;if ( $membercheck.length -ge 1)
&lt;/code&gt;&lt;code&gt;{
&lt;/code&gt;&lt;code&gt;Write-Host &amp;quot;User is already a member of&amp;quot; $_.name &amp;quot;&lt;/code&gt;b. No group addition made. &lt;code&gt;n&amp;quot;
&lt;/code&gt;&lt;code&gt;}
&lt;/code&gt;&lt;code&gt;else
&lt;/code&gt;&lt;code&gt;{
&lt;/code&gt;&lt;code&gt;$fqgroup.member.add(&amp;quot;$newuserdn&amp;quot;)
&lt;/code&gt;&lt;code&gt;$fqgroup.setinfo()
&lt;/code&gt;&lt;code&gt;}&lt;/code&gt;
&lt;code&gt;}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;So here&amp;rsquo;s the run down:&lt;/p&gt;

&lt;p&gt;The opening &lt;em&gt;Get-Mailbox&lt;/em&gt; line uses one of the Exchange 2007 snap-ins to get the mailbox object for our template account and saves it to the &lt;em&gt;$templaccn&lt;/em&gt; variable; substitute &lt;code&gt;[template account name]&lt;/code&gt; with the name of your template account. I also set the &lt;em&gt;$newuser&lt;/em&gt; variable to the name of the user who&amp;rsquo;s group membership we will be modifying. This is just because the script is used for user creation, so you might want to change the variable name to something like &lt;em&gt;$user&lt;/em&gt; or &lt;em&gt;$moduser&lt;/em&gt;; just be sure to change the variable throughout your code!&lt;/p&gt;

&lt;p&gt;The next two lines are used in conjunction with each other to find all groups of which the template account is a member. You could also replace these two lines with &lt;code&gt;Get-Group | Where-Object { $_.Members -match $templaccn }&lt;/code&gt;, but that first collects &lt;em&gt;ALL&lt;/em&gt; the groups in your environment and then runs them through a filter of &lt;code&gt;Where-Object&lt;/code&gt;. I have found the filterid way to be much quicker.&lt;/p&gt;

&lt;p&gt;For each group, we then first save the distinguished name to the _$groupdn _variable, then use the Powershell ADSI wrapper to store its full ADSI object as &lt;em&gt;$fqgroup&lt;/em&gt;. I usually prefix &lt;em&gt;fq&lt;/em&gt; to variables for full ADSI objecs to denote their type, but you can obviously use something like _adObj** **_whatever convention you like. The &lt;em&gt;member&lt;/em&gt; property for the group is a multi-valued property that contains the groups members, so using &lt;em&gt;Where-Object&lt;/em&gt; we effectively set a value to &lt;em&gt;$membercheck&lt;/em&gt; only if our user is a member of that group. As I was using this to create new users, this was probably not completely necessary, but it was good practice anyway.&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;if&lt;/em&gt; statement there just throws out that the user is already a member of the group if &lt;em&gt;$membercheck&lt;/em&gt; had any value set, otherwise it proceeds to adding the user to the group.&lt;/p&gt;

&lt;p&gt;We then use the &lt;em&gt;add()&lt;/em&gt;  method of the member property of the ADSI object for our group, supplying our user&amp;rsquo;s distinguished name as an argument, and use &lt;em&gt;setInfo()&lt;/em&gt; to apply the changes to the ADSI object.&lt;/p&gt;

&lt;p&gt;Now, the reason this was tough to do in the first place, and why I ended up later having so much trouble with removing group memberships and making other modifications, is because the &lt;em&gt;$fqgroup&lt;/em&gt; ADSI object does not display any methods! You can read all the properties you want, but for some reason the Powershell design team thought it would be a good idea to hide the methods, even though they are there. If you don&amp;rsquo;t believe me, try this:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$domroot = [adsi]&#39;&#39;&lt;/code&gt;
`&lt;/p&gt;

&lt;h2 id=&#34;distinguishedname&#34;&gt;distinguishedName&lt;/h2&gt;

&lt;p&gt;{DC=i-worx,DC=ca}
`&lt;/p&gt;

&lt;p&gt;Try just typing &lt;em&gt;$domroot&lt;/em&gt;. It should return something like:
&lt;code&gt;
[PS] C:\&amp;gt;$domroot&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;distinguishedname-1&#34;&gt;`distinguishedName&lt;/h2&gt;

&lt;p&gt;{DC=test,DC=local}`&lt;/p&gt;

&lt;p&gt;Alright, now try using Get-Member to get some info on this ADSI object: &lt;code&gt;$domroot | Get-Member&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;All of those seem to be Properties, right, with no methods? Hmm&amp;hellip; For more info on this, check out &lt;a href=&#34;http://blogs.technet.com/benp/archive/2007/03/05/benp-s-basic-guide-to-managing-active-directory-objects-with-powershell.aspx&#34;&gt;Benpâ€™s Basic Guide to Managing Active Directory Objects with PowerShell&lt;/a&gt; as well as &lt;a href=&#34;http://pathologicalscripter.wordpress.com/2006/09/28/invisible-methods-for-adsi/&#34;&gt;&amp;ldquo;Invisible&amp;rdquo; methods for ADSI?&lt;/a&gt; from the Pathological Scripter.&lt;/p&gt;

&lt;p&gt;Anyway, all this to show that it doesn&amp;rsquo;t seem to be as straightforward as we might have hoped.&lt;/p&gt;

&lt;p&gt;So, that seems to have covered &lt;em&gt;adding&lt;/em&gt; users to groups&amp;hellip;now what if I want to &lt;em&gt;remove&lt;/em&gt; a user&amp;rsquo;s group memberships? Part II of this post will cover that&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>