<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Networking on Hugo&#39;s Blog</title>
    <link>http://blog.slabnet.com/tags/networking/</link>
    <description>Recent content in Networking on Hugo&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>hugo@slabnet.com (Hugo Slabbert)</managingEditor>
    <webMaster>hugo@slabnet.com (Hugo Slabbert)</webMaster>
    <copyright>&amp;copy; 2016 Hugo Slabbert. &lt;a href=&#34;http://creativecommons.org/licenses/by/4.0/&#34;&gt;Some rights reserved&lt;/a&gt;. Please attribute properly and link back.</copyright>
    <lastBuildDate>Wed, 28 Sep 2016 07:17:17 -0700</lastBuildDate>
    <atom:link href="http://blog.slabnet.com/tags/networking/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>What BCP38 Can and Cannot Do</title>
      <link>http://blog.slabnet.com/post/what-bcp38-can-and-cannot-do/</link>
      <pubDate>Wed, 28 Sep 2016 07:17:17 -0700</pubDate>
      <author>hugo@slabnet.com (Hugo Slabbert)</author>
      <guid>http://blog.slabnet.com/post/what-bcp38-can-and-cannot-do/</guid>
      <description>

&lt;p&gt;We&amp;rsquo;re coming through what is seeming like a tipping point in the history of DDoS on the Internet.  Rather than targeting a company or online gaming, one of the largest DDoS attacks ever &lt;a href=&#34;http://krebsonsecurity.com/2016/09/krebsonsecurity-hit-with-record-ddos/&#34;&gt;targeted an individual&lt;/a&gt;, Brian Krebs, most likely for &lt;a href=&#34;https://krebsonsecurity.com/2016/09/israeli-online-attack-service-vdos-earned-600000-in-two-years/&#34;&gt;his work exposing a so-called &amp;ldquo;booter service&amp;rdquo;&lt;/a&gt;, a DDoS-for-hire outfit called vDOS, which ultimately led to &lt;a href=&#34;https://krebsonsecurity.com/2016/09/alleged-vdos-proprietors-arrested-in-israel/&#34;&gt;the alleged proprietors being arrested&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;a-brief-history-of-dos-volumes&#34;&gt;A brief history of DoS volumes&lt;/h2&gt;

&lt;p&gt;Public information about DDoS attack volumes are generally sparse outside of news releases and blog posts of DDoS mitigation companies, but even as late as last year, attacks of around 400 Gbps were exceptional events and pretty much the biggest the Internet had seen.  Attacks weighing in at 600 Gbps are said to have been reported in private, but generally haven&amp;rsquo;t hit public knowledge. In the space of a week, we&amp;rsquo;ve seen attacks reach those levels and &lt;em&gt;way&lt;/em&gt; beyond.  There are reports of &lt;em&gt;much&lt;/em&gt; more frequent attacks against common targets, with volumes far above average.  OVH, an international Internet service and hosting provider, reported attacks of over 1 Tbps just the night before the attack on KrebsOnSecurity:&lt;/p&gt;

&lt;blockquote class=&#34;twitter-tweet&#34;&gt;&lt;p lang=&#34;en&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/Dominik28111&#34;&gt;@Dominik28111&lt;/a&gt; we got 2 huge multi DDoS: 1156Gbps then 901Gbps &lt;a href=&#34;https://t.co/NyFTr6KLCC&#34;&gt;pic.twitter.com/NyFTr6KLCC&lt;/a&gt;&lt;/p&gt;&amp;mdash; Octave Klaba / Oles (@olesovhcom) &lt;a href=&#34;https://twitter.com/olesovhcom/status/778019962036314112&#34;&gt;September 19, 2016&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;

&lt;p&gt;This is an unprecedented escalation in attack volumes and frequency, and this state of affairs cannot go on.  The Internet is &lt;em&gt;the&lt;/em&gt; platform for discussion in our era, and it is simply unacceptable, whether you are a security researcher, a political activist, someone with an unpopular opinion, or simply someone running a blog for fun, that your voice on the Internet could be silenced by goons with digital cannons because they don&amp;rsquo;t like what you have to say, or simply for the lulz.&lt;/p&gt;

&lt;p&gt;After getting &lt;a href=&#34;https://krebsonsecurity.com&#34;&gt;krebsonsecurity.com&lt;/a&gt; back online on 2016-09-24, Krebs responded to the recent events with a report and call to action in &lt;a href=&#34;https://krebsonsecurity.com/2016/09/the-democratization-of-censorship/&#34;&gt;The Democritizaton of Censorship&lt;/a&gt;.  In it, he calls for a renewed effort on implementing &lt;a href=&#34;http://blog.slabnet.com/post/clarifying-ddos-related-terms/#bcp38&#34;&gt;BCP38&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Known as BCP38, its use prevents insecure resources on an ISPs network (hacked servers, computers, routers, DVRs, etc.) from being leveraged in such powerful denial-of-service attacks.&lt;/p&gt;

&lt;p&gt;&amp;hellip;&lt;/p&gt;

&lt;p&gt;BCP38 is designed to filter such spoofed traffic, so that it never even traverses the network of an ISP that’s adopted the anti-spoofing measures. However, there are non-trivial economic reasons that many ISPs fail to adopt this best practice. &lt;a href=&#34;http://www.internetsociety.org/deploy360/blog/2014/07/anti-spoofing-bcp-38-and-the-tragedy-of-the-commons/&#34;&gt;This blog post&lt;/a&gt; from the Internet Society does a good job of explaining why many ISPs ultimately decide not to implement BCP38.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;As we face denial of service attacks, it is important for us to be clear on what tools we have in our arsenal to defend against DDoS attacks.&lt;/p&gt;

&lt;h2 id=&#34;no-spoofing-no-benefit-to-bcp38&#34;&gt;No spoofing?  No benefit to BCP38&lt;/h2&gt;

&lt;p&gt;I will be very clear that I am a strong proponent of BCP38.  There are objections from some members the network operator community that need to be addressed and solutions to some valid network use cases that need to be developed, but on the whole we should be working to push spoof-detection and mitigation as a default state rather than throwing our hands up in the air and saying it&amp;rsquo;s too hard or a futile effort.&lt;/p&gt;

&lt;p&gt;That said: BCP38 does &lt;strong&gt;NOT&lt;/strong&gt; defend against direct network attacks that do not use source address spoofing.  Period.&lt;/p&gt;

&lt;p&gt;BCP38&amp;rsquo;s sole function is to drop traffic from invalid (spoofed) source addresses.  Now, spoofing &lt;em&gt;can&lt;/em&gt; be used in direct attacks in order to provide source address obfuscation, but those attacks need to be &amp;ldquo;one and done&amp;rdquo; vectors, e.g. SYN flood attacks or UDP-based attacks that hinge simply on a single packet making its way from the traffic originator (the host we&amp;rsquo;re talking about that&amp;rsquo;s using spoofing) to the target.&lt;/p&gt;

&lt;p&gt;A direct, TCP-based attack that requires a TCP 3-way handshake to complete &lt;em&gt;cannot&lt;/em&gt; use source address spoofing, as the SYN-ACK back from the target will go to a spoofed address and never reach the attacker to complete the TCP session setup.  As the TCP session setup never completes, any direct attack that requires a valid TCP session will not be able to function.  If source address spoofing is not being used, BCP38 has absolutely &lt;strong&gt;zero&lt;/strong&gt; impact on that traffic; it&amp;rsquo;s not spoofed, so BCP38 let&amp;rsquo;s it pass (as it should).&lt;/p&gt;

&lt;p&gt;But, the &lt;a href=&#34;http://krebsonsecurity.com/2016/09/krebsonsecurity-hit-with-record-ddos/&#34;&gt;post-mortem breakdown&lt;/a&gt; from Krebs indicates that these attacks did not use reflection &amp;amp; amplification:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;But according to Akamai, none of the attack methods employed in Tuesday night’s assault on KrebsOnSecurity relied on amplification or reflection. Rather, many were garbage Web attack methods that require a legitimate connection between the attacking host and the target, including SYN, GET and POST floods.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Note the &amp;ldquo;legitimate connection&amp;rdquo; part there, which I am reading as a valid TCP session.&lt;/p&gt;

&lt;p&gt;Akamai&amp;rsquo;s Martin McKeay also goes on to say that this traffic cannot be spoofed:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;McKeay explained that the source of GRE traffic can’t be spoofed or faked the same way DDoS attackers can spoof DNS traffic. Nor can junk Web-based DDoS attacks like those mentioned above.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Now, I &lt;a href=&#34;http://blog.slabnet.com/post/gre-reflection/&#34;&gt;took some exception&lt;/a&gt; to the statement that GRE traffic cannot be spoofed, and to be fair you can fake a GET or POST as long as you don&amp;rsquo;t care if the TCP session is invalid and the web server at the other end will reject it, but the point here is that the analysis of the attack describes it as consisting of direct attacks including legitimate, completed TCP sessions, &lt;em&gt;without&lt;/em&gt; spoofing taking place.&lt;/p&gt;

&lt;p&gt;Krebs touches on this again later in the Democritization piece when talking about the IoT devices likely participating in the attack:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Some readers on Twitter have asked why the attackers would have “burned” so many compromised systems with such an overwhelming force against my little site. After all, they reasoned, the attackers showed their hand in this assault, exposing the Internet addresses of a huge number of compromised devices that might otherwise be used for actual money-making cybercriminal activities&amp;hellip;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Again: if they&amp;rsquo;re exposing their IP addresses, that means we&amp;rsquo;re talking about abuse traffic that does &lt;em&gt;not&lt;/em&gt; have a spoofed source, which means whether or not BCP38 is implemented on the networks housing the attack sources has &lt;strong&gt;zero&lt;/strong&gt; bearing on the effectiveness of the attack.&lt;/p&gt;

&lt;p&gt;Krebs does later touch on the possibility of initiatives to require secure-by-default deployments for IoT devices, but that basically amounts to two sentences at the end of the &lt;em&gt;Shaming the Spoofers&lt;/em&gt; section.  In light of these attacks being claimed as direct and unspoofed, efforts to secure end hosts would really be the only effective countermeasure, as source address spoofing mitigation has zero effect on traffic that doesn&amp;rsquo;t spoof its source address.&lt;/p&gt;

&lt;p&gt;I aim to more about BCP38 in the near future, but I want to state again for emphasis that this post is &lt;em&gt;not&lt;/em&gt; a criticism of BCP38 or any kind of statement that BCP38 adoption is pointless or futile.  On the contrary: I wholeheartedly support any efforts to further BCP38 adoption, push for BCP38 adoption on any networks under my control, and believe it is critical to enabling attribution of abuse traffic and mitigation of reflected (and amplified) DDoS attacks.  But, we should not imagine that even getting full BCP38 coverage of the entire Internet will in any way impact network abuse and DDoS attacks that do not use source address spoofing.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Clarifying DDoS-related terms</title>
      <link>http://blog.slabnet.com/post/clarifying-ddos-related-terms/</link>
      <pubDate>Sun, 25 Sep 2016 20:47:02 -0700</pubDate>
      <author>hugo@slabnet.com (Hugo Slabbert)</author>
      <guid>http://blog.slabnet.com/post/clarifying-ddos-related-terms/</guid>
      <description>

&lt;p&gt;I&amp;rsquo;ll be writing a bit more about DDoS attacks and security, and so I thought it would be handy to jot down some commonly used terms in one place.  I&amp;rsquo;ll also look at how some of those terms are interrelated.&lt;/p&gt;

&lt;h2 id=&#34;the-terms&#34;&gt;The terms&lt;/h2&gt;

&lt;h3 id=&#34;spoofing&#34;&gt;Spoofing&lt;/h3&gt;

&lt;p&gt;As relates to TCP/IP, &amp;ldquo;spoofing&amp;rdquo; really just refers to forging some part of IP communications.  You could, for example, spoof a source port to have response data thrown at a listening application that wasn&amp;rsquo;t expecting it, but generally we&amp;rsquo;re talking about forging the source IP address in an IP packet.&lt;/p&gt;

&lt;p&gt;IP spoofing can be used to simply hide your identity in cases where replies back from the target are not necessary in order to complete an attack.&lt;/p&gt;

&lt;p&gt;For example, TCP SYN floods cause resource exhaustion on the target by making it set up many half-open TCP connections.  The attacker does not need to actually ACK replies back from the server in order to exhaust server resources, so spoofing the source IP in the SYN flood packets means (a) the attacker&amp;rsquo;s true IP remains hidden from the target and (b) any replies the target generates to the attack traffic will not reach the attacker, so the attacker can expend relatively fewer resources while making the target expend both more processing and bandwidth resources.&lt;/p&gt;

&lt;p&gt;Similarly, any connectionless attack where garbage, volumetric data is thrown at a target could also use any random source IP address.  For example, a compromised host could be instructed to send random data at a target using a spoofed source IP address in order to not reveal the true IP of the compromised host.  This reduces the risk of the zombied attack host being exposed, and increases the chances that the attacker can use the bot again in future attacks.&lt;/p&gt;

&lt;p&gt;Spoofing can also be used in reflection attacks.&lt;/p&gt;

&lt;h3 id=&#34;reflection&#34;&gt;Reflection&lt;/h3&gt;

&lt;p&gt;A reflection attack uses source address spoofing in order to have the attack bounce of off a &amp;ldquo;reflector&amp;rdquo; of some sort and on to the attack target.  The attacker uses spoofing to forge the source IP address of its traffic to be that of their target.  A request is then sent to the reflector, soliticing a response.  The response traffic, though, is sent not back to the attacker but rather on to the attack target.  This is because the reflector has no way of knowing the source of the traffic aside from the source IP address in the packets it receives, so all it can do is send responses to that IP address.&lt;/p&gt;

&lt;p&gt;The most basic example of this would be sending an ICMP echo request (ping) to some host on the Internet and setting the source IP address to that of the attack target.  The pinged host will then send an ICMP echo reply to the source IP of the packet, which is the attack target.  This isn&amp;rsquo;t really a very efficient method on the attacker&amp;rsquo;s part, though, as they have to use the same amount of resources and bandwidth as the target, if not more.  A 1500-byte echo request sent from the attacker results in a 1500-byte echo reply generated by the reflector and that 1500-byte echo reply being received by the target.  So:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The attacker:

&lt;ul&gt;
&lt;li&gt;uses 1500 bytes of upload bandwidth&lt;/li&gt;
&lt;li&gt;has to generate that 1500 byte echo request&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;The reflector:

&lt;ul&gt;
&lt;li&gt;uses 1500 bytes of download bandwith&lt;/li&gt;
&lt;li&gt;has to generate a 1500 byte ICMP echo reply&lt;/li&gt;
&lt;li&gt;uses 1500 bytes of upload bandwidth&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;The target just has to:

&lt;ul&gt;
&lt;li&gt;receive a 1500-byte echo reply&lt;/li&gt;
&lt;li&gt;do some very basic processing to realize it has to discard it&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To pack a bigger punch, reflection needs to be paired with amplification.&lt;/p&gt;

&lt;h3 id=&#34;amplification&#34;&gt;Amplification&lt;/h3&gt;

&lt;p&gt;This is where things start to get interesting on the volumetric DDoS front.  We&amp;rsquo;ve spoofed a source IP and sent a request to a server somewhere on the Internet so that the response gets sent to our target instead of back to us.  No how do we tip the scales to get a bigger attack?&lt;/p&gt;

&lt;p&gt;We need two things to pull this off:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;We need to be able to send a single packet to the reflector and have it reply with our attack traffic.&lt;/li&gt;
&lt;li&gt;We need to hit on some protocol or service that will make the reflector generate a larger amount of traffic to send to the attacker than we sent to the reflector in the first place.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;For #1, the idea here is that since we are spoofing our source address, something like TCP won&amp;rsquo;t work.  TCP requires a 3-step handshake between before the connection is open and data can go between client and server.  If we hit step 1 (SYN), but step 2 from the server back to the client (SYN-ACK) doesn&amp;rsquo;t come back to us but rather goes to the target, we can&amp;rsquo;t complete the TCP connection setup and so we can&amp;rsquo;t trigger a big bunch of data.  This is actually good design: it&amp;rsquo;s BAD for a single, small request from the client to be able to trigger a BIG response from the server, and the TCP 3-way handshake sidesteps that issue.  Connectionless protocols like UDP could work, though, as UDP-based protocols are more likely send the actual reply to a client request right from the word &amp;ldquo;go!&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Requirement #2 is pretty obvious, but how do we pull that off?  Well, common targets have been identified that by design violate the best practice suggestion of not returning more than is received on the first request/packet.  A list of some of those:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;NTP&lt;/li&gt;
&lt;li&gt;CHARGEN&lt;/li&gt;
&lt;li&gt;DNS, especially with EDNS&lt;/li&gt;
&lt;li&gt;SSDP&lt;/li&gt;
&lt;li&gt;SNMP&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Now we can single a &lt;em&gt;single&lt;/em&gt; packet to reflector with a spoofed source IP and have that reflector send up to almost &lt;strong&gt;600 times&lt;/strong&gt; that amount of traffic to our target.&lt;/p&gt;

&lt;h3 id=&#34;bcp38&#34;&gt;BCP38&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;BC-whatnow?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;BCP&lt;/em&gt; stands for Best Current Practice, which are documents put forth by the Internet Engineering Task Force (IETF) to, well, describe best current practices ;)&lt;/p&gt;

&lt;p&gt;Basically, rather than documenting how protocols themselves should function, BCPs provide guidelines on recommended configurations and operation of those protocols in real-world scenarios.  For example, &lt;a href=&#34;https://tools.ietf.org/html/bcp46&#34;&gt;BCP46&lt;/a&gt;, &lt;em&gt;Recommended Internet Service Provider Security Services and Procedures&lt;/em&gt;,  describes common security practices that ISPs should implement.  This isn&amp;rsquo;t about which protocols to use, but &lt;em&gt;how&lt;/em&gt; to implement and configure the &lt;em&gt;use&lt;/em&gt; of those protocols.  BCPs also have a regular RFC number, with BCP38 being RFC2827.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://tools.ietf.org/html/bcp38&#34;&gt;BCP38&lt;/a&gt; is titled &lt;em&gt;Network Ingress Filtering: Defeating Denial of Service Attacks which employ IP Source Address Spoofing&lt;/em&gt;.  Recognizing that source address spoofing can facilitate denial of service attacks, the IETF drafted BCP38 to cut source address spoofing off at the knees.&lt;/p&gt;

&lt;p&gt;In a network that has implemented BCP38, when a packet with a spoofed source IP address reaches the ISP&amp;rsquo;s router, the router checks the source IP address of the packet.  If the source address has been legitimately assigned to the customer, then the packet is permitted.  If the source address is not in an address range that has been assigned to the customer, it is discarded/dropped.  The spoofed packet will never get to a DoS target or a reflector, because it is dropped as soon as it enters the ISP&amp;rsquo;s network.&lt;/p&gt;

&lt;h3 id=&#34;unicast-reverse-path-forwarding-urpf&#34;&gt;Unicast Reverse Path Forwarding (uRPF)&lt;/h3&gt;

&lt;p&gt;Usually, configuring a router to accept or drop traffic, especially based on source address rather than destination, is accomplished through access control lists (ACLs), aka firewall filters.  In implementing BCP38, an ACL would be applied on the customer-facing interface of the ISP&amp;rsquo;s router, and would match source addresses of packets received on that interface.  That&amp;hellip;starts to become a pain to manage. Aside from addressing an interface, you also now need to configure and apply an ACL for each customer-facing interface on every single access router in your network.  Sure, you can probably work this into your customer turn-up process and service provisioning, but it&amp;rsquo;s an extra step that either needs to be done manually or have some development and QA time thrown at it.  Couldn&amp;rsquo;t we just have an &amp;ldquo;enable source address spoof filtering&amp;rdquo; checkbox or something?&lt;/p&gt;

&lt;p&gt;&lt;em&gt;uRPF to the rescue!&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Unicast Reverse Path Forwarding checks the source address of packet received on a router interface and then does a route lookup for that source address.  If a route for the source address is found &lt;strong&gt;and&lt;/strong&gt; points &lt;em&gt;out&lt;/em&gt; the interface on which the packet was received, the packet is forwarded.  If &lt;em&gt;not&lt;/em&gt;, the packet is discarded.  We&amp;rsquo;ll get into more details &lt;a href=&#34;#and-bcp38-and-urpf&#34;&gt;below&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;how-do-these-all-go-together&#34;&gt;How do these all go together?&lt;/h2&gt;

&lt;p&gt;Each of the first three terms we covered - spoofing, reflection, and amplification -  builds on the ones before it.  I can &lt;em&gt;spoof&lt;/em&gt; a packet without doing any reflection or amplification.  In order to &lt;em&gt;reflect&lt;/em&gt; traffic, I need to spoof the source IP address in the traffic I send out.  But, I can still &lt;em&gt;reflect&lt;/em&gt; traffic without that using &lt;em&gt;amplification&lt;/em&gt;, as we saw in the original ping example.&lt;/p&gt;

&lt;p&gt;Now: I &lt;em&gt;can&lt;/em&gt; technically use amplification without spoofing and reflection, but that would really just be normal user traffic rather than attack traffic.  We mentioned DNS as a potential reflection vector.  Well, if I send a small DNS request to my DNS server and get a larger response back, technically that&amp;rsquo;s amplification (small request sent; large response triggered).  But, that&amp;rsquo;s not DoS traffic.&lt;/p&gt;

&lt;p&gt;In order to use amplification in a DoS scenario, then, I need a &lt;em&gt;reflector&lt;/em&gt; to amplify the attack traffic for me, and I need to use &lt;em&gt;spoofing&lt;/em&gt; to direct the reflected response to the target rather than having it come back to me.&lt;/p&gt;

&lt;h3 id=&#34;where-would-one-technique-be-used-over-another&#34;&gt;Where would one technique be used over another?&lt;/h3&gt;

&lt;p&gt;If all I care about is throwing traffic directly at a target and obfuscating my source address, I can just use spoofing.  TCP SYN floods would be an example, or cases where random volumetric data is launched at a target (though at least the latter would more commonly leverage reflected and amplified attacks).&lt;/p&gt;

&lt;p&gt;If the attacker has access to services that are vulnerable to amplification, it generally doesn&amp;rsquo;t make too much sense to just use bare spoofing and reflection rather than just tossing more resources at the vector that provides amplification.  That said, an ICMP flood could be an example of a reflected attack that does not leverage amplification.&lt;/p&gt;

&lt;p&gt;Finally, as mentioned above, an amplified attack requires both spoofing (to direct requests at the target rather than the attacker) and reflection (to provide the amplification) as well, and is the staple of large-scale volumetric DDoS attacks.&lt;/p&gt;

&lt;h3 id=&#34;and-bcp38-and-urpf&#34;&gt;And BCP38 and uRPF?&lt;/h3&gt;

&lt;p&gt;BCP38 can&amp;rsquo;t prevent all denial of service attacks from happening, but it does prevent spoofing.  If attackers do not have access to networks that let them spoof source addresses, they are unable to cover their tracks.  If a host in a botnet assumes it can send out spoofed traffic, its attack traffic will not reach the target, and the attack is mitigated.  If the zombied host is able to detect that its spoofed traffic cannot get through, an attack operator &lt;em&gt;may&lt;/em&gt; choose to simply send attack traffic directly to the target without spoofing.  This exposes the zombie host, though, so that abuse from the host can be reported and it can be cleaned up or neutralized so that it cannot be used in future attacks.  Since spoofing is also required for an amplified attack, a network that implements BCP38 cannot be used to launch an amplified reflected attack, which is where the big guns in volumetric DDoS come from.&lt;/p&gt;

&lt;p&gt;Some examples might also help illustrate this.&lt;/p&gt;

&lt;p&gt;Users X and Y are connected to &lt;code&gt;RouterA&lt;/code&gt; on two different networks:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; -------------------------
| UserX                   |______________
| 2001:db8:a:1111::100/64 |               \  -----------------------
 -------------------------      ge-1/0/0.0 \| 2001:db8:a:1111::1/64 |
                                            |-----------------------|
                                            |        RouterA        |
                                            |-----------------------|
 -------------------------      ge-2/0/0.0 /| 2001:db8:a:ffff::1/64 |
| UserY                   |______________ /  -----------------------
| 2001:db8:a:ffff::100/64 |
 -------------------------
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For our example, let&amp;rsquo;s assume this is a &lt;em&gt;very&lt;/em&gt; simple router and just has these two connected networks and then a default route out another interface, &lt;code&gt;ge-0/0/0.0&lt;/code&gt;, so its routing table looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Network                 Type        Next-Hop            Via Interface
::/0                    static      2001:db8:aaaa::a    ge-0/0/0.0
2001:db8:a:1111::1/128  Local       -                   ge-1/0/0.0
2001:db8:a:1111::/64    Direct      -                   ge-1/0/0.0
2001:db8:a:ffff::1/128  Local       -                   ge-2/0/0.0
2001:db8:a:ffff::/64    Direct      -                   ge-2/0/0.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;UserX thinks he&amp;rsquo;s super 1337 and wants to launch a TCP SYN flood attack against UserY without having his source IP being revealed.  This is simple spoofing without reflection or amplification.  He spoofs the source IP address in his attack packets and sets it to some other random IP; let&amp;rsquo;s say &lt;code&gt;2001:db8:bad:d00d::1337&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;UserX sends the traffic with the spoofed source IP to his ISP gateway address of &lt;code&gt;2001:db8:a:1111::1&lt;/code&gt;, which is on &lt;code&gt;RouterA&lt;/code&gt;.  Now, &lt;code&gt;RouterA&lt;/code&gt; does have uRPF configured on the interface to which UserX is connected, so it does a route lookup on the source address.  For the spoofed attack packets, that would be &lt;code&gt;2001:db8:bad:d00d::1337&lt;/code&gt;.  &lt;code&gt;RouterA&lt;/code&gt; finds that it does &lt;em&gt;not&lt;/em&gt; have a route for that address going out that interface; it doesn&amp;rsquo;t even have a route for that destination &lt;em&gt;at all&lt;/em&gt; aside from its default route.&lt;/p&gt;

&lt;p&gt;Note that this also works in cases where a route for the source address &lt;em&gt;is&lt;/em&gt; found, but on a different interface.  Suppose UserX takes a different tack and decides to use an amplified &lt;a href=&#34;https://blog.cloudflare.com/understanding-and-mitigating-ntp-based-ddos-attacks/&#34;&gt;NTP reflection attack&lt;/a&gt; against UserY, so he picks &lt;em&gt;UserY&amp;rsquo;s&lt;/em&gt; address as his spoofed source IP.  UserX crafts an NTP monlist query to a vulnerable NTP server that will serve as his reflector and amplify the attack traffic, and sends the packet on its way via his gateway on &lt;code&gt;RouterA&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In this case when &lt;code&gt;RouterA&lt;/code&gt; does a route lookup during its uRPF check it &lt;em&gt;will&lt;/em&gt; find a route for the source IP in the packet, &lt;code&gt;2001:db8:a:ffff::100&lt;/code&gt;, because that address lives in UserY&amp;rsquo;s network of &lt;code&gt;2001:db8:a:ffff::/64&lt;/code&gt; that is directly connected on its ge-2/0/0.0 interface.  But, UserX&amp;rsquo;s spoofed packet came in on ge-1/0/0.0, &lt;em&gt;not&lt;/em&gt; on ge-2/0/0.0.  Since the route for the source address in the packet does &lt;em&gt;not&lt;/em&gt; go via the input interface of the packet, &lt;code&gt;RouterA&lt;/code&gt; discards the packet and the attack is neutralized.&lt;/p&gt;

&lt;h2 id=&#34;wrapping-up&#34;&gt;Wrapping Up&lt;/h2&gt;

&lt;p&gt;DDoS attacks are a &lt;em&gt;very&lt;/em&gt; broad subject and there are lots of nuances to deal with.  This post aimed to just start scratching the surface and to provide an introductory reference for some of these terms, and I will be digging into this topic in more detail in future posts.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GRE Reflection?</title>
      <link>http://blog.slabnet.com/post/gre-reflection/</link>
      <pubDate>Thu, 22 Sep 2016 20:23:52 -0700</pubDate>
      <author>hugo@slabnet.com (Hugo Slabbert)</author>
      <guid>http://blog.slabnet.com/post/gre-reflection/</guid>
      <description>

&lt;p&gt;Recently, we&amp;rsquo;re seeing an uptick in GRE traffic as part of a DDoS mix.  Most prominently, GRE featured as the biggest volume contributor in the record 600+ Gbps attack on &lt;a href=&#34;http://krebsonsecurity.com&#34;&gt;krebsonsecurity.com&lt;/a&gt;.  (Note that the site is currently offline as it&amp;rsquo;s finding a new home, so any links to krebsonsecurity.com will reference &lt;a href=&#34;http://archive.org&#34;&gt;The Internet Archive&lt;/a&gt; instead.)&lt;/p&gt;

&lt;p&gt;An initial tweet from &lt;a href=&#34;https://twitter.com/briankrebs&#34;&gt;@briankrebs&lt;/a&gt; listed GRE in the attack traffic mix:&lt;/p&gt;

&lt;blockquote class=&#34;twitter-tweet&#34;&gt;&lt;p lang=&#34;en&#34; dir=&#34;ltr&#34;&gt;per the last tweet, they threw it all at my site; SYN Flood, GET Flood, ACK Flood, POST Flood, GRE Protocol Flood]; 665.00 Gbps;143.50 Mpps&lt;/p&gt;&amp;mdash; briankrebs (@briankrebs) &lt;a href=&#34;https://twitter.com/briankrebs/status/778402188267778048&#34;&gt;September 21, 2016&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;

&lt;p&gt;&amp;hellip;and Krebs later confirmed more details in KrebsOnSecurity&amp;rsquo;s &lt;a href=&#34;https://web.archive.org/web/20160922021000/http://krebsonsecurity.com/2016/09/krebsonsecurity-hit-with-record-ddos/&#34;&gt;own article&lt;/a&gt; reporting on the attack:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Preliminary analysis of the attack traffic suggests that perhaps the biggest chunk of the attack came in the form of traffic designed to look like it was generic routing encapsulation (GRE) data packets, a communication protocol used to establish a direct, point-to-point connection between network nodes.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Now, volumetric DDoS attacks will generally use amplification vectors like open DNS resolvers, misconfigured or vulnerable NTP or SNMP servers, SSDP, etc. in order to boost the attack volume.  Those amplifiers are also often vulnerable to reflection attacks, where the attacker spoofs the source address in the initial amplification trigger packets so that the amplified replies hit the target rather than the attacker.  This can be pulled off because these exploited amplification vectors are stateless and UDP-based, and so a single spoofed packet from the attacker will trigger the amplified reply destined for the target.  A TCP-based attack could yield a larger amplification factor (e.g. just think of pulling off an HTTP GET of a GB+ file!), but a TCP 3-way handshake would never complete successfully with a spoofed source address, and even if somehow it could, the attacker would have to keep ACK-ing somehow in order to keep the transfer going.  GRE we are told, however, could not have a spoofed source address (also from &lt;a href=&#34;https://web.archive.org/web/20160922021000/http://krebsonsecurity.com/2016/09/krebsonsecurity-hit-with-record-ddos/&#34;&gt;the same Krebs article&lt;/a&gt;):&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;McKeay explained that the source of GRE traffic can’t be spoofed or faked the same way DDoS attackers can spoof DNS traffic.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;GRE is not known to have an amplification vector, and I haven&amp;rsquo;t been able to think of one.  But is it true that source IPs cannot be spoofed in GRE?  &lt;em&gt;Note that this is an untested theory and still needs to be validated.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;We need to dig a bit into what GRE actually is in order to test that out.  The tl;dr is &lt;a href=&#34;#so-how-would-this-be-reflected&#34;&gt;below&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;intro-to-gre-skip-if-you-know-how-gre-and-keepalives-work&#34;&gt;Intro to GRE; skip if you know how GRE and keepalives work&lt;/h3&gt;

&lt;p&gt;Generic Routing Encapsulation, or GRE, is basically a way to wrap up or &amp;ldquo;encapsulate&amp;rdquo; a packet inside another packet.  Why would you want to do that?  Most commonly, GRE is used to tunnel traffic across a set of intermediate routers that would not the traffic being tunneled because they don&amp;rsquo;t have a route for its destination.  If you&amp;rsquo;ve ever connected to a corporate VPN or used a site-to-site IPSEC VPN, it&amp;rsquo;s pretty much the same idea except GRE does not provide encryption.&lt;/p&gt;

&lt;p&gt;Now, GRE tunnels are completely stateless.  This means no agreement needs to made between two routers passing each other GRE traffic about e.g. whether a tunnel is up or down, how many packets have traversed it, anything to do with sequence numbers, etc.  The sending router slaps a GRE header on the packet to be encapsulated, fires it in the direction of the destination router, and calls it a day.  The receiving router similarly just strips off the GRE header and forwards the inner packet if it can.  Now, I&amp;rsquo;ll qualify this by stating that the receiving router can have multiple different GRE tunnels configured, so it should look at the source and destination IP in the GRE header (and possibly a GRE key) in order to figure out which GRE tunnel the packet belongs to, but again this is a stateless operation.&lt;/p&gt;

&lt;p&gt;Why would we use GRE rather than something like an IPSEC tunnel?  Well, not all traffic needs network layer privacy.  If we need to somehow tunnel traffic that would be crossing the public Internet in the clear &lt;em&gt;anyway&lt;/em&gt;, there&amp;rsquo;s no point in encrypting it just because we need to tunnel it.  Ditto if we have traffic for an encrypted protocol (HTTPS, SSH), where we just need to tunnel it to pull routing tricks but don&amp;rsquo;t need to bother encrypting something at the network layer when it has &lt;em&gt;already&lt;/em&gt; been encrypted.  By skipping encryption and state, GRE is computationally &amp;ldquo;cheap&amp;rdquo;, so it can be leveraged in places with constrained resources (low end routers forwarding a decent chunk of traffic) or high scale requirements (big fat routers that need to forward a &lt;strong&gt;lot&lt;/strong&gt; of traffic in hardware at line rate).&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s all nice, but what does this have to do with traffic reflection?  How can we make some endpoint forward on traffic to our target?&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ll preface this &lt;em&gt;again&lt;/em&gt; by saying this is thus far just theoretical, and still needs to be labbed up to test it out.  This is very much a hypothesis of &amp;ldquo;If GRE could be reflected, could this be a possible way?&amp;rdquo; rather than a statement that &amp;ldquo;GRE can be reflected, and this is how&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Now, we may sometimes still want to figure out if the other end of a GRE tunnel is alive and that the tunnel is &amp;ldquo;up&amp;rdquo;, but there is no keepalive mechanism in the GRE spec.  So, how do we do that?  Well, Cisco, $deity bless &amp;lsquo;em, never could pass up an opportunity to invent protocols where there is a dirth of RFC coverage, and so GRE keepalives are born.&lt;/p&gt;

&lt;p&gt;GRE keepalives effectively trick the remote router into forwarding the keepalive packet &lt;em&gt;back&lt;/em&gt; to the sender, all without having to know anything about keepalives itself.  Let&amp;rsquo;s say &lt;code&gt;RouterA&lt;/code&gt; is the one sending keepalives, and &lt;code&gt;RouterB&lt;/code&gt; is the other end of the GRE tunnel.&lt;/p&gt;

&lt;p&gt;When &lt;code&gt;RouterA&lt;/code&gt; usually sends traffic through the GRE tunnel, it will take the original packet of user or transit traffic and stuff an additional IP and GRE header onto it.  There are some additional fields available in the GRE header, but effectively it&amp;rsquo;s damn near nothing and just says &amp;lsquo;the actual inner packet is &lt;em&gt;this&lt;/em&gt; protocol&amp;rsquo;.  That will generally by IPv4 (0x0800) or IPv6 (0x86dd), but really can be any EtherType.  The new IP header has a source IP set to &lt;code&gt;RouterA&lt;/code&gt;&amp;rsquo;s own IP address and a destination IP set to &lt;code&gt;RouterB&lt;/code&gt;&amp;rsquo;s IP address.  The original user traffic would have looked like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; -----------------------------------------------------
| IP | SRC IP          | DST             | IP PAYLOAD |
|    | 2001:db8:5::100 | 2001:db8:6::200 |            |
 -----------------------------------------------------
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With the additional GRE and IP header added, the encapsulated packet looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; ----------------------------------------------------------------------------------------------------------------
| IP | SRC IP        | DST IP        | GRE | GRE           | IP | SRC IP          | DST             | IP PAYLOAD |
|    | 2001:db8:1::1 | 2001:db8:2::2 |     | PROTOCOL=08dd |    | 2001:db8:5::100 | 2001:db8:6::200 |            |
 ----------------------------------------------------------------------------------------------------------------
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Great!  So the GRE packet gets over to &lt;code&gt;RouterB&lt;/code&gt;, it sees its own IP address as the destination and realizes that it has to do something with this packet rather than forward it on.  The L4 protocol is 47 (GRE), so if it can handle GRE then it realizes it has to check what protocol is next in the stack (e.g. IPv4 as 0x0800 or IPv6 as 0x08dd as described above), strip the GRE header, and then forward the inner packet on its merry way (provided it has a route for the destination, the TTL isn&amp;rsquo;t expired, etc. etc.).&lt;/p&gt;

&lt;p&gt;So how does &lt;code&gt;RouterA&lt;/code&gt; get &lt;code&gt;RouterB&lt;/code&gt; to forward keepalives back to &lt;code&gt;RouterA&lt;/code&gt;, especially as we said that &lt;code&gt;RouterB&lt;/code&gt; doesn&amp;rsquo;t know anything about dem dere fancy GRE keepalives?&lt;/p&gt;

&lt;p&gt;&lt;code&gt;RouterA&lt;/code&gt; actually encapsulates its keepalive packet in GRE &lt;strong&gt;twice&lt;/strong&gt;.  The outer headers are what we&amp;rsquo;ve discussed here already:  source = &lt;code&gt;RouterA&lt;/code&gt; IP, destination = &lt;code&gt;RouterB&lt;/code&gt; IP, and then a GRE header.  The inner packet in this case is not some user traffic that&amp;rsquo;s going to the networks at &lt;code&gt;RouterB&lt;/code&gt;, but rather &lt;strong&gt;another GRE packet&lt;/strong&gt;.  &lt;code&gt;RouterA&lt;/code&gt; crafts the packet so that the source IP on this &lt;em&gt;inner&lt;/em&gt; GRE packet is actually &lt;em&gt;&lt;code&gt;RouterB&lt;/code&gt;&lt;/em&gt;&amp;rsquo;s IP address, with the destination set to &lt;em&gt;its own&lt;/em&gt; IP address (that is, &lt;code&gt;RouterA&lt;/code&gt;&amp;rsquo;s IP).  That header stack looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; --------------------------------------------------------------------------------------------------------------------
| IP | SRC IP        | DST IP        | GRE | GRE             | IP | SRC IP        | DST IP        | GRE | GRE        |
|    | 2001:db8:1::1 | 2001:db8:2::2 |     | PROTOCOL=0x08dd |    | 2001:db8:2::2 | 2001:db8:1::1 |     | PROTOCOL=0 |
 --------------------------------------------------------------------------------------------------------------------
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For this double-encapsulated packet, things at &lt;code&gt;RouterB&lt;/code&gt; start off just as described above for regular user traffic.  &lt;code&gt;RouterB&lt;/code&gt; receives the GRE packet, sees the destination IP is its own, checks the GRE header for the protocol number value and then strips it, and then starts to look at what it should do with the inner payload.  Except now, that inner payload is &lt;em&gt;another&lt;/em&gt; GRE packet, with a source IP address set to &lt;code&gt;RouterB&lt;/code&gt;&amp;rsquo;s own IP and a destination IP set to &lt;code&gt;RouterA&lt;/code&gt;&amp;rsquo;s IP.&lt;/p&gt;

&lt;p&gt;So what does &lt;code&gt;RouterB&lt;/code&gt; do?  Well, like a good router, it looks up its route for &lt;code&gt;RouterA&lt;/code&gt; and dutifully forwards the packet (with the outer IP and GRE header stripped) back over to thattaway.  &lt;code&gt;RouterA&lt;/code&gt; receives the packet, sees its own IP address as the destination, sees a GRE header, and evaluates that.  GRE keepalives use a special protocol number of 0 (as opposed to 0x0800 or x08dd for IPv4 and IPv6 as mentioned above).  On seeing the protocol field set to 0, &lt;code&gt;RouterA&lt;/code&gt; realizes this is a GRE keepalive packet, and it resets the GRE tunnel keepalive counter to zero and considers the GRE tunnel to be up.&lt;/p&gt;

&lt;h3 id=&#34;so-how-would-this-be-reflected&#34;&gt;So how would this be reflected?&lt;/h3&gt;

&lt;p&gt;Who says the attacker has to set the destination IP address in the inner GRE packet to their own address?&lt;/p&gt;

&lt;p&gt;The very &lt;em&gt;design&lt;/em&gt; of this is such that &lt;code&gt;RouterB&lt;/code&gt; in our example does not need to know anything about keepalives or the double encapsulation setup.  It does no correlation or checks between the source and destination IP addresses on the outer IP header and the inner ones.  There is nothing stopping me from setting the destination address to whatever the hell I want.  If I want to hit someone at 2001:db8:ffff::a, I just do:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; -----------------------------------------------------------------------------------------------------------------------
| IP | SRC IP        | DST IP        | GRE | GRE             | IP | SRC IP        | DST IP           | GRE | GRE        |
|    | 2001:db8:1::1 | 2001:db8:2::2 |     | PROTOCOL=0x08dd |    | 2001:db8:2::2 | 2001:db8:ffff::a |     | PROTOCOL=0 |
 -----------------------------------------------------------------------------------------------------------------------
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To think of it: What&amp;rsquo;s stopping me from stuffing a whole IP packet in there rather than just a minimal-payload GRE keepalive?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; --------------------------------------------------------------------------------------------------------------------------------------
| IP | SRC IP        | DST IP        | GRE | GRE             | IP | SRC IP        | DST IP           | GRE | GRE             | IPv6    |
|    | 2001:db8:1::1 | 2001:db8:2::2 |     | PROTOCOL=0x08dd |    | 2001:db8:2::2 | 2001:db8:ffff::a |     | PROTOCOL=0x08dd | PAYLOAD |
 --------------------------------------------------------------------------------------------------------------------------------------
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I see two possible permutations of this, with varying levels of difficulty and probability of execution:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;1.&lt;/code&gt; Targeted to configured GRE tunnels, with source address spoofing&lt;/p&gt;

&lt;p&gt;Routers processing GRE traffic &lt;em&gt;should&lt;/em&gt; generally first check if they have a tunnel configured with matching source and destination IPs.  If I&amp;rsquo;m &lt;code&gt;RouterB&lt;/code&gt;, I should first check that I have a GRE tunnel configured towards &lt;code&gt;RouterA&lt;/code&gt;&amp;rsquo;s IP before I process GRE packets with source IPs of &lt;code&gt;RouterA&lt;/code&gt; destined for me.  Provided routers are doing that correctly, this means an attack would have to (a) know about (or guess / scan for) configured GRE tunnels on potential reflectors in order to pull this off and (b) successfully spoof &lt;code&gt;RouterA&lt;/code&gt;&amp;rsquo;s source IP.&lt;/p&gt;

&lt;p&gt;A search could theoretically be possible by sending a GRE-encapsulated packet towards &lt;code&gt;RouterB&lt;/code&gt; with an IP payload destined for an IP that the attacker controls, with the source IP on the outer IP header being varied as the IPs being tested.  The attacker could then listen for that payload packet, and if received, confirm that the tested source IP does in fact have a GRE tunnel configured with &lt;code&gt;RouterB&lt;/code&gt;.  This is a massive search space, though, as each potential reflector would need to be tested against each other potential source IP on the public Internet.  Even in the IPv4 Internet, this is huge, as you&amp;rsquo;re dealing with &lt;code&gt;(2**32) * (2**32 - 1)&lt;/code&gt; combinations (minus RFC1918, multicast, documentation, and other reserved ranges).  That&amp;rsquo;s 18,446,744,069,414,584,320 combinations, for those keeping score at home.  Unless the attackers have prior knowledge about potential reflectors and configured GRE tunnels, this possibility is somewhat remote.&lt;/p&gt;

&lt;p&gt;Second to that, this requires that the attacker be able to spoof &lt;code&gt;RouterA&lt;/code&gt;&amp;rsquo;s IP address.  This is less of a problem given that networks that fail to &lt;a href=&#34;http://www.bcp38.info/index.php/Main_Page&#34;&gt;implement&lt;/a&gt; &lt;a href=&#34;https://tools.ietf.org/html/bcp38&#34;&gt;BCP38&lt;/a&gt; seem to be plentiful, as we see from the prevalance of reflected traffic we have because of spoofed sources.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;2.&lt;/code&gt;  To any GRE-capable router, but dependent on GRE-processing flaw&lt;/p&gt;

&lt;p&gt;GRE has not yet been subjected to the same scrutiny as e.g. DNS and NTP following those becoming heavily abused in reflected and amplified DDoS attacks (how I do not miss the &lt;a href=&#34;https://blog.cloudflare.com/technical-details-behind-a-400gbps-ntp-amplification-ddos-attack/&#34;&gt;Christmas of 2013&lt;/a&gt;&amp;hellip;).  A hypothetical laxity in the processing of GRE traffic could potentially make this a &lt;em&gt;much&lt;/em&gt; easier vector to exploit for reflection while simultaneously being &lt;em&gt;very&lt;/em&gt; difficult for origin and reflector networks to combat.&lt;/p&gt;

&lt;p&gt;If &lt;code&gt;RouterB&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; validate that it has a GRE tunnel configured with the source IP of the GRE packet, the attacker could send a GRE packet to &lt;code&gt;RouterB&lt;/code&gt; &lt;em&gt;simply from his own IP address or any other IP they want&lt;/em&gt; and still have &lt;code&gt;RouterB&lt;/code&gt; process the GRE packet, strip the header, and pass on the inner packet to the target.  This &lt;em&gt;drastically&lt;/em&gt; reduces the search space on the IPv4 Internet from 18,446,744,069,414,584,320 down to &lt;code&gt;2**32&lt;/code&gt; or roughly 4 billion.  It also means the attacker &lt;em&gt;does not even need to spoof the target&amp;rsquo;s IP address&lt;/em&gt; in order to pull of the reflection attack, as the target IP is contained &lt;em&gt;within&lt;/em&gt; the encapsulated packet.  They can opt to spoof their source IP if they have access to a network that does not implement BCP38, but this would be an optional step that provides additional obfuscation and shielding from attribution and traceback.&lt;/p&gt;

&lt;p&gt;What would make this difficult to combat on the service provider side is that, should such a GRE processing flaw exist, this could be pulled of without any address spoofing, so even networks that properly implement BCP38 would let it pass.  GRE also has perfectly legitimate uses on business and residential networks and so any transiting or hosting networks for the attacker and reflector likely would not be able to simply drop the offending traffic.  Fixes would be dependent on either ACLs or firmware updates on the reflectors.&lt;/p&gt;

&lt;p&gt;The chances of this second reflection option are somewhat remote, as having a flaw of this nature could potentially result in a serious NAT traversal flaw as well.  If I can send &lt;code&gt;RouterB&lt;/code&gt; a GRE-encapsulated packet from any source and have it forward the inner packet along provided it has &lt;em&gt;any&lt;/em&gt; GRE configured it on, that could smash through NAT.&lt;/p&gt;

&lt;h3 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;This post was largely the result of spitballing how reflection might be possible with GRE traffic in light of the recent spike of GRE in large, volumetric DDoS attacks.  There is no amplification in this, and if anything the attacker needs to send &lt;em&gt;more&lt;/em&gt; data than reaches the target as they send the payload with 2x GRE/IP header stacks whereas the reflector strips the outer IP &amp;amp; GRE headers and just sends the one, but should it prove possible it could still be useful for obfuscation.&lt;/p&gt;

&lt;p&gt;On the plus side, While DDoS targets/victims with complex networks or applications may not be able to drop GRE entirely, simpler targets (e.g. websites) should be able to simply drop any IP protocol 47 (GRE) traffic destined for the site without impact.  Given the traffic volumes we&amp;rsquo;re seeing, that&amp;rsquo;s pretty much completely contingent on having a large scale DDoS scrubbing service in place, but at least the rulesets should be fairly simple provided there aren&amp;rsquo;t actual production GRE tunnels or e.g. PPTP VPNs (&lt;a href=&#34;https://www.schneier.com/academic/pptp/faq.html&#34;&gt;for shame&lt;/a&gt;!) hiding behind the scrubbing service.  If needed, static GRE tunnels should be easier to pin down in rulesets with specific source and destinations IPs than PPTP VPNs that use GRE and have varied source IPs.&lt;/p&gt;

&lt;p&gt;P.S. If this hyptothetical flaw in processing of GRE&amp;rsquo;d traffic &lt;em&gt;does&lt;/em&gt; end up being a thing, I call dibs on the &amp;ldquo;pick a trendy and somewhat obnoxious name for software flaws&amp;rdquo; rights and dub this &lt;strong&gt;GREflector&lt;/strong&gt;!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Ubuntu Xenial and systemd network online target</title>
      <link>http://blog.slabnet.com/post/ubuntu-xenial-and-systemd-network-online-target/</link>
      <pubDate>Mon, 12 Sep 2016 21:42:27 -0700</pubDate>
      <author>hugo@slabnet.com (Hugo Slabbert)</author>
      <guid>http://blog.slabnet.com/post/ubuntu-xenial-and-systemd-network-online-target/</guid>
      <description>&lt;p&gt;So, I&amp;rsquo;m bringing a little Chromebox back into use on our home network to do
some basic network services: dhcp, dns, and probably actually using it as a
router (long story; tl;dr TekSavvy says they&amp;rsquo;ll give you a /56 but then the
VDSL modem they sell you can&amp;rsquo;t do DHCPv6-PD properly).&lt;/p&gt;

&lt;p&gt;Anyway&amp;hellip;&lt;/p&gt;

&lt;p&gt;I slapped Ubuntu 16.04 Xenial server on it and started plugging away at a
couple of things.  I opted to use ISC&amp;rsquo;s newer &lt;a href=&#34;https://www.isc.org/kea/&#34;&gt;Kea DHCP
server&lt;/a&gt; rather than &lt;code&gt;isc-dhcp-server&lt;/code&gt;.  Little did I
know that Ubuntu and systemd had other ideas&amp;hellip;&lt;/p&gt;

&lt;p&gt;After getting Kea set up, I reboot the box at some point, only to have my wife
ask me if I&amp;rsquo;m screwing around on the network&amp;hellip;because her laptop didn&amp;rsquo;t get an
IP after coming back from sleep.&lt;/p&gt;

&lt;p&gt;Here I find this gem:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Sep 12 19:20:00 cherry kea-dhcp4[2384]: 2016-09-12 19:20:00.548 INFO  [kea-dhcp4.dhcp4/2384] DHCP4_STARTING Kea DHCPv4 server version 1.0.0 starting
Sep 12 19:20:00 cherry kea-dhcp4[2384]: 2016-09-12 19:20:00.550 INFO  [kea-dhcp4.dhcpsrv/2384] DHCPSRV_CFGMGR_ADD_IFACE listening on interface enp1s0
Sep 12 19:20:00 cherry kea-dhcp4[2384]: 2016-09-12 19:20:00.550 INFO  [kea-dhcp4.dhcpsrv/2384] DHCPSRV_CFGMGR_SOCKET_TYPE_DEFAULT &amp;quot;dhcp-socket-type&amp;quot; not specified , using default socket type raw
Sep 12 19:20:00 cherry kea-dhcp4[2384]: 2016-09-12 19:20:00.554 INFO  [kea-dhcp4.dhcp4/2384] DHCP4_CONFIG_NEW_SUBNET a new subnet has been added to configuration: 10.128.1.0/24 with params: valid-lifetime=4000
Sep 12 19:20:00 cherry kea-dhcp4[2384]: 2016-09-12 19:20:00.555 INFO  [kea-dhcp4.dhcpsrv/2384] DHCPSRV_MEMFILE_DB opening memory file lease database: type=memfile universe=4
Sep 12 19:20:00 cherry kea-dhcp4[2384]: 2016-09-12 19:20:00.557 INFO  [kea-dhcp4.dhcpsrv/2384] DHCPSRV_MEMFILE_LEASE_FILE_LOAD loading leases from file /var/lib/kea/kea-leases4.csv
Sep 12 19:20:00 cherry kea-dhcp4[2384]: 2016-09-12 19:20:00.599 INFO  [kea-dhcp4.dhcp4/2384] DHCP4_CONFIG_COMPLETE DHCPv4 server has completed configuration: added IPv4 subnets: 1; DDNS: disabled
Sep 12 19:20:00 cherry kea-dhcp4[2384]: 2016-09-12 19:20:00.600 WARN  [kea-dhcp4.dhcpsrv/2384] DHCPSRV_OPEN_SOCKET_FAIL failed to open socket: the interface enp1s0 is down or has no usable IPv4 addresses config
Sep 12 19:20:00 cherry kea-dhcp4[2384]: 2016-09-12 19:20:00.600 WARN  [kea-dhcp4.dhcpsrv/2384] DHCPSRV_NO_SOCKETS_OPEN no interface configured to listen to DHCP traffic
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Google (and Ubuntu&amp;rsquo;s Launchpad) to the rescue!
&lt;a href=&#34;https://bugs.launchpad.net/ubuntu/+source/isc-kea/+bug/1550784&#34;&gt;Apparently&lt;/a&gt;,
&lt;code&gt;kea-dhcp4-server.service&lt;/code&gt; doesn&amp;rsquo;t include any references to &lt;code&gt;network.target&lt;/code&gt;
or &lt;code&gt;network-online.target&lt;/code&gt; for some reason.  K; add those&amp;hellip;no joy.&lt;/p&gt;

&lt;p&gt;Try &lt;a href=&#34;https://bugs.launchpad.net/ubuntu/+source/isc-kea/+bug/1550784/comments/3&#34;&gt;post
#3&lt;/a&gt;
by &lt;a href=&#34;https://launchpad.net/~halvors&#34;&gt;halvors&lt;/a&gt; in that thread?  No dice&amp;hellip;&lt;/p&gt;

&lt;p&gt;Trusty ol&amp;rsquo; &lt;a href=&#34;http://unix.stackexchange.com/questions/210604/how-to-write-a-systemd-service-unit-file-so-it-waits-until-a-specific-interface&#34;&gt;StackExchange
post&lt;/a&gt;
in an attempt to wait for a specific interface rather than just networking in
general?  Yea no:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Sep 12 21:37:07 cherry systemd[1]: kea-dhcp4-server.service: Control process exited, code=exited status=203
Sep 12 21:37:07 cherry systemd[1]: Failed to start ISC KEA IPv4 DHCP daemon.
Sep 12 21:37:07 cherry systemd[1]: kea-dhcp4-server.service: Unit entered failed state.
Sep 12 21:37:07 cherry systemd[1]: kea-dhcp4-server.service: Failed with result &#39;exit-code&#39;.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The fix?  &lt;a href=&#34;http://unix.stackexchange.com/a/217768&#34;&gt;This beauty&lt;/a&gt; of a wrapper
around an &lt;code&gt;ifquery&lt;/code&gt; shell script with some sleep` thrown in there for good measure:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[Unit]
Description=Wait for all &amp;quot;auto&amp;quot; /etc/network/interfaces to be up for network-online.target
Documentation=man:interfaces(5) man:ifup(8)
DefaultDependencies=no
After=local-fs.target
Before=network-online.target

[Service]
Type=oneshot
RemainAfterExit=yes
TimeoutStartSec=2min
ExecStart=/bin/sh -ec &#39;\
  for i in $(ifquery --list --exclude lo --allow auto); do INTERFACES=&amp;quot;$INTERFACES$i &amp;quot;; done; \
  [ -n &amp;quot;$INTERFACES&amp;quot; ] || exit 0; \
  while ! ifquery --state $INTERFACES &amp;gt;/dev/null; do sleep 1; done; \
  for i in $INTERFACES; do while [ -e /run/network/ifup-$i.pid ]; do sleep 0.2; done; done&#39;

[Install]
WantedBy=network-online.target
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Throw that beauty in &lt;code&gt;/etc/systemd/system/ifup-wait-all-auto.service&lt;/code&gt;,
install it with &lt;code&gt;sudo systemctl enable ifup-wait-all-auto.service&lt;/code&gt;, and then
actually have the &lt;code&gt;network-online.target&lt;/code&gt; references in your &lt;code&gt;systemd&lt;/code&gt; unit
definitions work properly.&lt;/p&gt;

&lt;p&gt;Ain&amp;rsquo;t progress grand?&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Windows Media Player 11 Breaks Internet Connectivity</title>
      <link>http://blog.slabnet.com/post/windows-media-player-11-breaks-internet-connectivity/</link>
      <pubDate>Wed, 13 Aug 2008 06:18:52 +0000</pubDate>
      <author>hugo@slabnet.com (Hugo Slabbert)</author>
      <guid>http://blog.slabnet.com/post/windows-media-player-11-breaks-internet-connectivity/</guid>
      <description>&lt;p&gt;Alright, so the title for this post seems pretty out there, but I can guarantee you that I have come across this on multiple machines. I&amp;rsquo;m not saying &amp;ldquo;If you install Windows Media Player 11 on your computer, networking will break,&amp;rdquo; I&amp;rsquo;m just saying that if you experience the symptoms outlined below and you&amp;rsquo;re stuck, trying uninstalling WM11 and the WM11 codec; you just might get lucky.&lt;/p&gt;

&lt;p&gt;So, one of the other techs in the office calls me over: He&amp;rsquo;s been beating his head against a wall with a remote user being unable to get internet connectivity on his Windows XP workstation. The tech has been on this thing for hours, tried just about everything he can think of shy of a workstation rebuild, and he&amp;rsquo;s looking for some team support. I have him throw the ticket my way; I figure that another set of eyes can only be helpful. With a bit of digging, we isolate the symptoms:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Full connectivity to the local server is available&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Name resolution is still solid&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Pings are working to both local and remote addresses&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Anything higher up the stack than pings only work locally, and bail as soon as you cross a router. This includes file shares, RDP, FTP, HTTP/s, MAPI, and I&amp;rsquo;m guessing anything else higher than layer 4.&lt;!-- more --&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;About an hour or so later, I&amp;rsquo;m still not much farther than tech #1. I&amp;rsquo;ve reset the stack (&lt;code&gt;netsh winsock reset&lt;/code&gt;) and rebooted, updated/reinstalled the network card drivers&amp;hellip;heck, we even flashed the BIOS on the thing. Nothing&amp;hellip;zip&amp;hellip;nada.&lt;/p&gt;

&lt;p&gt;So, I start thinking that maybe some weird malware/adware that&amp;rsquo;s intercepting traffic and messing things up. I head to Add/Remove Programs and start flipping through the titles. Nothing nasty stands out, but I remove the IE toolbars just to be safe as I&amp;rsquo;ve had some personal experience with Yahoo! toolbars causing crashes and other wonderful things in IE. Still no joy&amp;hellip;&lt;/p&gt;

&lt;p&gt;I get to the end of the list and see an entry for &lt;strong&gt;Windows Media Player 11 codec&lt;/strong&gt;. Now, fortunate for me, I don&amp;rsquo;t play around with WM much, and so I&amp;rsquo;m not sure if this is a legit piece of software or not. What I do remember is a particularly nasty experience I had with some malware hiding in the Add/Remove Programs list as media players. So, out goes the codec. Just for good measure, I toss Windows Media Player 11 after the reboot and then reboot the box again. Why? To be honest, I really don&amp;rsquo;t know&amp;hellip;I was getting pretty low on bright ideas at that point.&lt;/p&gt;

&lt;p&gt;And then, magically, internet connectivity is restored. I still don&amp;rsquo;t have an explanation for this, but for some reason, Windows Media Player 11 being installed on that machine (and at least two others so far in my experience!) caused Layer 5+ routed networking to bail. If you have a KB or something that explains this, please let me know, &amp;lsquo;cause that&amp;rsquo;s just messed up!&lt;/p&gt;

&lt;p&gt;Anyhow: Happy hunting!&lt;/p&gt;

&lt;p&gt;JaS&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>