<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ddos on Hugo&#39;s Blog</title>
    <link>http://blog.slabnet.com/tags/ddos/</link>
    <description>Recent content in Ddos on Hugo&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>hugo@slabnet.com (Hugo Slabbert)</managingEditor>
    <webMaster>hugo@slabnet.com (Hugo Slabbert)</webMaster>
    <copyright>&amp;copy; 2016 Hugo Slabbert. &lt;a href=&#34;http://creativecommons.org/licenses/by/4.0/&#34;&gt;Some rights reserved&lt;/a&gt;. Please attribute properly and link back.</copyright>
    <lastBuildDate>Sun, 25 Sep 2016 20:47:02 -0700</lastBuildDate>
    <atom:link href="http://blog.slabnet.com/tags/ddos/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Clarifying DDoS-related terms</title>
      <link>http://blog.slabnet.com/post/clarifying-ddos-related-terms/</link>
      <pubDate>Sun, 25 Sep 2016 20:47:02 -0700</pubDate>
      <author>hugo@slabnet.com (Hugo Slabbert)</author>
      <guid>http://blog.slabnet.com/post/clarifying-ddos-related-terms/</guid>
      <description>

&lt;p&gt;I&amp;rsquo;ll be writing a bit more about DDoS attacks and security, and so I thought it would be handy to jot down some commonly used terms in one place.  I&amp;rsquo;ll also look at how some of those terms are interrelated.&lt;/p&gt;

&lt;h2 id=&#34;the-terms&#34;&gt;The terms&lt;/h2&gt;

&lt;h3 id=&#34;spoofing&#34;&gt;Spoofing&lt;/h3&gt;

&lt;p&gt;As relates to TCP/IP, &amp;ldquo;spoofing&amp;rdquo; really just refers to forging some part of IP communications.  You could, for example, spoof a source port to have response data thrown at a listening application that wasn&amp;rsquo;t expecting it, but generally we&amp;rsquo;re talking about forging the source IP address in an IP packet.&lt;/p&gt;

&lt;p&gt;IP spoofing can be used to simply hide your identity in cases where replies back from the target are not necessary in order to complete an attack.&lt;/p&gt;

&lt;p&gt;For example, TCP SYN floods cause resource exhaustion on the target by making it set up many half-open TCP connections.  The attacker does not need to actually ACK replies back from the server in order to exhaust server resources, so spoofing the source IP in the SYN flood packets means (a) the attacker&amp;rsquo;s true IP remains hidden from the target and (b) any replies the target generates to the attack traffic will not reach the attacker, so the attacker can expend relatively fewer resources while making the target expend both more processing and bandwidth resources.&lt;/p&gt;

&lt;p&gt;Similarly, any connectionless attack where garbage, volumetric data is thrown at a target could also use any random source IP address.  For example, a compromised host could be instructed to send random data at a target using a spoofed source IP address in order to not reveal the true IP of the compromised host.  This reduces the risk of the zombied attack host being exposed, and increases the chances that the attacker can use the bot again in future attacks.&lt;/p&gt;

&lt;p&gt;Spoofing can also be used in reflection attacks.&lt;/p&gt;

&lt;h3 id=&#34;reflection&#34;&gt;Reflection&lt;/h3&gt;

&lt;p&gt;A reflection attack uses source address spoofing in order to have the attack bounce of off a &amp;ldquo;reflector&amp;rdquo; of some sort and on to the attack target.  The attacker uses spoofing to forge the source IP address of its traffic to be that of their target.  A request is then sent to the reflector, soliticing a response.  The response traffic, though, is sent not back to the attacker but rather on to the attack target.  This is because the reflector has no way of knowing the source of the traffic aside from the source IP address in the packets it receives, so all it can do is send responses to that IP address.&lt;/p&gt;

&lt;p&gt;The most basic example of this would be sending an ICMP echo request (ping) to some host on the Internet and setting the source IP address to that of the attack target.  The pinged host will then send an ICMP echo reply to the source IP of the packet, which is the attack target.  This isn&amp;rsquo;t really a very efficient method on the attacker&amp;rsquo;s part, though, as they have to use the same amount of resources and bandwidth as the target, if not more.  A 1500-byte echo request sent from the attacker results in a 1500-byte echo reply generated by the reflector and that 1500-byte echo reply being received by the target.  So:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The attacker:

&lt;ul&gt;
&lt;li&gt;uses 1500 bytes of upload bandwidth&lt;/li&gt;
&lt;li&gt;has to generate that 1500 byte echo request&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;The reflector:

&lt;ul&gt;
&lt;li&gt;uses 1500 bytes of download bandwith&lt;/li&gt;
&lt;li&gt;has to generate a 1500 byte ICMP echo reply&lt;/li&gt;
&lt;li&gt;uses 1500 bytes of upload bandwidth&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;The target just has to:

&lt;ul&gt;
&lt;li&gt;receive a 1500-byte echo reply&lt;/li&gt;
&lt;li&gt;do some very basic processing to realize it has to discard it&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To pack a bigger punch, reflection needs to be paired with amplification.&lt;/p&gt;

&lt;h3 id=&#34;amplification&#34;&gt;Amplification&lt;/h3&gt;

&lt;p&gt;This is where things start to get interesting on the volumetric DDoS front.  We&amp;rsquo;ve spoofed a source IP and sent a request to a server somewhere on the Internet so that the response gets sent to our target instead of back to us.  No how do we tip the scales to get a bigger attack?&lt;/p&gt;

&lt;p&gt;We need two things to pull this off:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;We need to be able to send a single packet to the reflector and have it reply with our attack traffic.&lt;/li&gt;
&lt;li&gt;We need to hit on some protocol or service that will make the reflector generate a larger amount of traffic to send to the attacker than we sent to the reflector in the first place.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;For #1, the idea here is that since we are spoofing our source address, something like TCP won&amp;rsquo;t work.  TCP requires a 3-step handshake between before the connection is open and data can go between client and server.  If we hit step 1 (SYN), but step 2 from the server back to the client (SYN-ACK) doesn&amp;rsquo;t come back to us but rather goes to the target, we can&amp;rsquo;t complete the TCP connection setup and so we can&amp;rsquo;t trigger a big bunch of data.  This is actually good design: it&amp;rsquo;s BAD for a single, small request from the client to be able to trigger a BIG response from the server, and the TCP 3-way handshake sidesteps that issue.  Connectionless protocols like UDP could work, though, as UDP-based protocols are more likely send the actual reply to a client request right from the word &amp;ldquo;go!&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Requirement #2 is pretty obvious, but how do we pull that off?  Well, common targets have been identified that by design violate the best practice suggestion of not returning more than is received on the first request/packet.  A list of some of those:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;NTP&lt;/li&gt;
&lt;li&gt;CHARGEN&lt;/li&gt;
&lt;li&gt;DNS, especially with EDNS&lt;/li&gt;
&lt;li&gt;SSDP&lt;/li&gt;
&lt;li&gt;SNMP&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Now we can single a &lt;em&gt;single&lt;/em&gt; packet to reflector with a spoofed source IP and have that reflector send up to almost &lt;strong&gt;600 times&lt;/strong&gt; that amount of traffic to our target.&lt;/p&gt;

&lt;h3 id=&#34;bcp38&#34;&gt;BCP38&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;BC-whatnow?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;BCP&lt;/em&gt; stands for Best Current Practice, which are documents put forth by the Internet Engineering Task Force (IETF) to, well, describe best current practices ;)&lt;/p&gt;

&lt;p&gt;Basically, rather than documenting how protocols themselves should function, BCPs provide guidelines on recommended configurations and operation of those protocols in real-world scenarios.  For example, &lt;a href=&#34;https://tools.ietf.org/html/bcp46&#34;&gt;BCP46&lt;/a&gt;, &lt;em&gt;Recommended Internet Service Provider Security Services and Procedures&lt;/em&gt;,  describes common security practices that ISPs should implement.  This isn&amp;rsquo;t about which protocols to use, but &lt;em&gt;how&lt;/em&gt; to implement and configure the &lt;em&gt;use&lt;/em&gt; of those protocols.  BCPs also have a regular RFC number, with BCP38 being RFC2827.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://tools.ietf.org/html/bcp38&#34;&gt;BCP38&lt;/a&gt; is titled &lt;em&gt;Network Ingress Filtering: Defeating Denial of Service Attacks which employ IP Source Address Spoofing&lt;/em&gt;.  Recognizing that source address spoofing can facilitate denial of service attacks, the IETF drafted BCP38 to cut source address spoofing off at the knees.&lt;/p&gt;

&lt;p&gt;In a network that has implemented BCP38, when a packet with a spoofed source IP address reaches the ISP&amp;rsquo;s router, the router checks the source IP address of the packet.  If the source address has been legitimately assigned to the customer, then the packet is permitted.  If the source address is not in an address range that has been assigned to the customer, it is discarded/dropped.  The spoofed packet will never get to a DoS target or a reflector, because it is dropped as soon as it enters the ISP&amp;rsquo;s network.&lt;/p&gt;

&lt;h3 id=&#34;unicast-reverse-path-forwarding-urpf&#34;&gt;Unicast Reverse Path Forwarding (uRPF)&lt;/h3&gt;

&lt;p&gt;Usually, configuring a router to accept or drop traffic, especially based on source address rather than destination, is accomplished through access control lists (ACLs), aka firewall filters.  In implementing BCP38, an ACL would be applied on the customer-facing interface of the ISP&amp;rsquo;s router, and would match source addresses of packets received on that interface.  That&amp;hellip;starts to become a pain to manage. Aside from addressing an interface, you also now need to configure and apply an ACL for each customer-facing interface on every single access router in your network.  Sure, you can probably work this into your customer turn-up process and service provisioning, but it&amp;rsquo;s an extra step that either needs to be done manually or have some development and QA time thrown at it.  Couldn&amp;rsquo;t we just have an &amp;ldquo;enable source address spoof filtering&amp;rdquo; checkbox or something?&lt;/p&gt;

&lt;p&gt;&lt;em&gt;uRPF to the rescue!&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Unicast Reverse Path Forwarding checks the source address of packet received on a router interface and then does a route lookup for that source address.  If a route for the source address is found &lt;strong&gt;and&lt;/strong&gt; points &lt;em&gt;out&lt;/em&gt; the interface on which the packet was received, the packet is forwarded.  If &lt;em&gt;not&lt;/em&gt;, the packet is discarded.  We&amp;rsquo;ll get into more details &lt;a href=&#34;#and-bcp38-and-urpf&#34;&gt;below&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;how-do-these-all-go-together&#34;&gt;How do these all go together?&lt;/h2&gt;

&lt;p&gt;Each of the first three terms we covered - spoofing, reflection, and amplification -  builds on the ones before it.  I can &lt;em&gt;spoof&lt;/em&gt; a packet without doing any reflection or amplification.  In order to &lt;em&gt;reflect&lt;/em&gt; traffic, I need to spoof the source IP address in the traffic I send out.  But, I can still &lt;em&gt;reflect&lt;/em&gt; traffic without that using &lt;em&gt;amplification&lt;/em&gt;, as we saw in the original ping example.&lt;/p&gt;

&lt;p&gt;Now: I &lt;em&gt;can&lt;/em&gt; technically use amplification without spoofing and reflection, but that would really just be normal user traffic rather than attack traffic.  We mentioned DNS as a potential reflection vector.  Well, if I send a small DNS request to my DNS server and get a larger response back, technically that&amp;rsquo;s amplification (small request sent; large response triggered).  But, that&amp;rsquo;s not DoS traffic.&lt;/p&gt;

&lt;p&gt;In order to use amplification in a DoS scenario, then, I need a &lt;em&gt;reflector&lt;/em&gt; to amplify the attack traffic for me, and I need to use &lt;em&gt;spoofing&lt;/em&gt; to direct the reflected response to the target rather than having it come back to me.&lt;/p&gt;

&lt;h3 id=&#34;where-would-one-technique-be-used-over-another&#34;&gt;Where would one technique be used over another?&lt;/h3&gt;

&lt;p&gt;If all I care about is throwing traffic directly at a target and obfuscating my source address, I can just use spoofing.  TCP SYN floods would be an example, or cases where random volumetric data is lauched at a target (though at least the latter would more commonly leverage reflected and amplified attacks).&lt;/p&gt;

&lt;p&gt;If the attacker has access to services that are vulnerable to amplification, it generally doesn&amp;rsquo;t make too much sense to just use bare spoofing and reflection rather than just tossing more resources at the vector that provides amplification.  That said, an ICMP flood could be an example of a reflected attack that does not leverage amplification.&lt;/p&gt;

&lt;p&gt;Finally, as mentioned above, an amplified attack requires both spoofing (to direct requests at the target rather than the attacker) and reflection (to provide the amplification) as well, and is the staple of large-scale volumetric DDoS attacks.&lt;/p&gt;

&lt;h3 id=&#34;and-bcp38-and-urpf&#34;&gt;And BCP38 and uRPF?&lt;/h3&gt;

&lt;p&gt;BCP38 can&amp;rsquo;t prevent all denial of service attacks from happening, but it does prevent spoofing.  If attackers do not have access to networks that let them spoof source addresses, they are unable to cover their tracks.  If a host in a botnet assumes it can send out spoofed traffic, its attack traffic will not reach the target, and the attack is mitigated.  If the zombied host is able to detect that its spoofed traffic cannot get through, an attack operator &lt;em&gt;may&lt;/em&gt; choose to simply send attack traffic directly to the target without spoofing.  This exposes the zombie host, though, so that abuse from the host can be reported and it can be cleaned up or neutralized so that it cannot be used in future attacks.  Since spoofing is also required for an amplified attack, a network that implements BCP38 cannot be used to launch an amplified reflected attack, which is where the big guns in volumetric DDoS come from.&lt;/p&gt;

&lt;p&gt;Some examples might also help illustrate this.&lt;/p&gt;

&lt;p&gt;Users X and Y are connected to &lt;code&gt;RouterA&lt;/code&gt; on two different networks:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; -------------------------
| UserX                   |______________
| 2001:db8:a:1111::100/64 |               \  -----------------------
 -------------------------      ge-1/0/0.0 \| 2001:db8:a:1111::1/64 |
                                            |-----------------------|
                                            |        RouterA        |
                                            |-----------------------|
 -------------------------      ge-2/0/0.0 /| 2001:db8:a:ffff::1/64 |
| UserY                   |______________ /  -----------------------
| 2001:db8:a:ffff::100/64 |
 -------------------------
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For our example, let&amp;rsquo;s assume this is a &lt;em&gt;very&lt;/em&gt; simple router and just has these two connected networks and then a default route out another interface, &lt;code&gt;ge-0/0/0.0&lt;/code&gt;, so its routing table looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Network                 Type        Next-Hop            Via Interface
::/0                    static      2001:db8:aaaa::a    ge-0/0/0.0
2001:db8:a:1111::1/128  Local       -                   ge-1/0/0.0
2001:db8:a:1111::/64    Direct      -                   ge-1/0/0.0
2001:db8:a:ffff::1/128  Local       -                   ge-2/0/0.0
2001:db8:a:ffff::/64    Direct      -                   ge-2/0/0.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;UserX thinks he&amp;rsquo;s super 1337 and wants to launch a TCP SYN flood attack against UserY without having his source IP being revealed.  This is simple spoofing without reflection or amplification.  He spoofs the source IP address in his attack packets and sets it to some other random IP; let&amp;rsquo;s say &lt;code&gt;2001:db8:bad:d00d::1337&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;UserX sends the traffic with the spoofed source IP to his ISP gateway address of &lt;code&gt;2001:db8:a:1111::1&lt;/code&gt;, which is on &lt;code&gt;RouterA&lt;/code&gt;.  Now, &lt;code&gt;RouterA&lt;/code&gt; does have uRPF configured on the interface to which UserX is connected, so it does a route lookup on the source address.  For the spoofed attack packets, that would be &lt;code&gt;2001:db8:bad:d00d::1337&lt;/code&gt;.  &lt;code&gt;RouterA&lt;/code&gt; finds that it does &lt;em&gt;not&lt;/em&gt; have a route for that address going out that interface; it doesn&amp;rsquo;t even have a route for that destination &lt;em&gt;at all&lt;/em&gt; aside from its default route.&lt;/p&gt;

&lt;p&gt;Note that this also works in cases where a route for the source address &lt;em&gt;is&lt;/em&gt; found, but on a different interface.  Suppose UserX takes a different tack and decides to use an amplified &lt;a href=&#34;https://blog.cloudflare.com/understanding-and-mitigating-ntp-based-ddos-attacks/&#34;&gt;NTP reflection attack&lt;/a&gt; against UserY, so he picks &lt;em&gt;UserY&amp;rsquo;s&lt;/em&gt; address as his spoofed source IP.  UserX crafts an NTP monlist query to a vulnerable NTP server that will serve as his reflector and amplify the attack traffic, and sends the packet on its way via his gateway on &lt;code&gt;RouterA&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In this case when &lt;code&gt;RouterA&lt;/code&gt; does a route lookup during its uRPF check it &lt;em&gt;will&lt;/em&gt; find a route for the source IP in the packet, &lt;code&gt;2001:db8:a:ffff::100&lt;/code&gt;, because that address lives in UserY&amp;rsquo;s network of &lt;code&gt;2001:db8:a:ffff::/64&lt;/code&gt; that is directly connected on its ge-2/0/0.0 interface.  But, UserX&amp;rsquo;s spoofed packet came in on ge-1/0/0.0, &lt;em&gt;not&lt;/em&gt; on ge-2/0/0.0.  Since the route for the source address in the packet does &lt;em&gt;not&lt;/em&gt; go via the input interface of the packet, &lt;code&gt;RouterA&lt;/code&gt; discards the packet and the attack is neutralized.&lt;/p&gt;

&lt;h2 id=&#34;wrapping-up&#34;&gt;Wrapping Up&lt;/h2&gt;

&lt;p&gt;DDoS attacks are a &lt;em&gt;very&lt;/em&gt; broad subject and there are lots of nuances to deal with.  This post aimed to just start scratching the surface and to provide an introductory reference for some of these terms, and I will be digging into this topic in more detail in future posts.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GRE Reflection?</title>
      <link>http://blog.slabnet.com/post/gre-reflection/</link>
      <pubDate>Thu, 22 Sep 2016 20:23:52 -0700</pubDate>
      <author>hugo@slabnet.com (Hugo Slabbert)</author>
      <guid>http://blog.slabnet.com/post/gre-reflection/</guid>
      <description>

&lt;p&gt;Recently, we&amp;rsquo;re seeing an uptick in GRE traffic as part of a DDoS mix.  Most prominently, GRE featured as the biggest volume contributor in the record 600+ Gbps attack on &lt;a href=&#34;http://krebsonsecurity.com&#34;&gt;krebsonsecurity.com&lt;/a&gt;.  (Note that the site is currently offline as it&amp;rsquo;s finding a new home, so any links to krebsonsecurity.com will reference &lt;a href=&#34;http://archive.org&#34;&gt;The Internet Archive&lt;/a&gt; instead.)&lt;/p&gt;

&lt;p&gt;An initial tweet from &lt;a href=&#34;https://twitter.com/briankrebs&#34;&gt;@briankrebs&lt;/a&gt; listed GRE in the attack traffic mix:&lt;/p&gt;

&lt;blockquote class=&#34;twitter-tweet&#34;&gt;&lt;p lang=&#34;en&#34; dir=&#34;ltr&#34;&gt;per the last tweet, they threw it all at my site; SYN Flood, GET Flood, ACK Flood, POST Flood, GRE Protocol Flood]; 665.00 Gbps;143.50 Mpps&lt;/p&gt;&amp;mdash; briankrebs (@briankrebs) &lt;a href=&#34;https://twitter.com/briankrebs/status/778402188267778048&#34;&gt;September 21, 2016&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;

&lt;p&gt;&amp;hellip;and Krebs later confirmed more details in KrebsOnSecurity&amp;rsquo;s &lt;a href=&#34;https://web.archive.org/web/20160922021000/http://krebsonsecurity.com/2016/09/krebsonsecurity-hit-with-record-ddos/&#34;&gt;own article&lt;/a&gt; reporting on the attack:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Preliminary analysis of the attack traffic suggests that perhaps the biggest chunk of the attack came in the form of traffic designed to look like it was generic routing encapsulation (GRE) data packets, a communication protocol used to establish a direct, point-to-point connection between network nodes.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Now, volumetric DDoS attacks will generally use amplification vectors like open DNS resolvers, misconfigured or vulnerable NTP or SNMP servers, SSDP, etc. in order to boost the attack volume.  Those amplifiers are also often vulnerable to reflection attacks, where the attacker spoofs the source address in the initial amplification trigger packets so that the amplified replies hit the target rather than the attacker.  This can be pulled off because these exploited amplification vectors are stateless and UDP-based, and so a single spoofed packet from the attacker will trigger the amplified reply destined for the target.  A TCP-based attack could yield a larger amplification factor (e.g. just think of pulling off an HTTP GET of a GB+ file!), but a TCP 3-way handshake would never complete successfully with a spoofed source address, and even if somehow it could, the attacker would have to keep ACK-ing somehow in order to keep the transfer going.  GRE we are told, however, could not have a spoofed source address (also from &lt;a href=&#34;https://web.archive.org/web/20160922021000/http://krebsonsecurity.com/2016/09/krebsonsecurity-hit-with-record-ddos/&#34;&gt;the same Krebs article&lt;/a&gt;):&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;McKeay explained that the source of GRE traffic can’t be spoofed or faked the same way DDoS attackers can spoof DNS traffic.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;GRE is not known to have an amplification vector, and I haven&amp;rsquo;t been able to think of one.  But is it true that source IPs cannot be spoofed in GRE?  &lt;em&gt;Note that this is an untested theory and still needs to be validated.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;We need to dig a bit into what GRE actually is in order to test that out.  The tl;dr is &lt;a href=&#34;#so-how-would-this-be-reflected&#34;&gt;below&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;intro-to-gre-skip-if-you-know-how-gre-and-keepalives-work&#34;&gt;Intro to GRE; skip if you know how GRE and keepalives work&lt;/h3&gt;

&lt;p&gt;Generic Routing Encapsulation, or GRE, is basically a way to wrap up or &amp;ldquo;encapsulate&amp;rdquo; a packet inside another packet.  Why would you want to do that?  Most commonly, GRE is used to tunnel traffic across a set of intermediate routers that would not the traffic being tunneled because they don&amp;rsquo;t have a route for its destination.  If you&amp;rsquo;ve ever connected to a corporate VPN or used a site-to-site IPSEC VPN, it&amp;rsquo;s pretty much the same idea except GRE does not provide encryption.&lt;/p&gt;

&lt;p&gt;Now, GRE tunnels are completely stateless.  This means no agreement needs to made between two routers passing each other GRE traffic about e.g. whether a tunnel is up or down, how many packets have traversed it, anything to do with sequence numbers, etc.  The sending router slaps a GRE header on the packet to be encapsulated, fires it in the direction of the destination router, and calls it a day.  The receiving router similarly just strips off the GRE header and forwards the inner packet if it can.  Now, I&amp;rsquo;ll qualify this by stating that the receiving router can have multiple different GRE tunnels configured, so it should look at the source and destination IP in the GRE header (and possibly a GRE key) in order to figure out which GRE tunnel the packet belongs to, but again this is a stateless operation.&lt;/p&gt;

&lt;p&gt;Why would we use GRE rather than something like an IPSEC tunnel?  Well, not all traffic needs network layer privacy.  If we need to somehow tunnel traffic that would be crossing the public Internet in the clear &lt;em&gt;anyway&lt;/em&gt;, there&amp;rsquo;s no point in encrypting it just because we need to tunnel it.  Ditto if we have traffic for an encrypted protocol (HTTPS, SSH), where we just need to tunnel it to pull routing tricks but don&amp;rsquo;t need to bother encrypting something at the network layer when it has &lt;em&gt;already&lt;/em&gt; been encrypted.  By skipping encryption and state, GRE is computationally &amp;ldquo;cheap&amp;rdquo;, so it can be leveraged in places with constrained resources (low end routers forwarding a decent chunk of traffic) or high scale requirements (big fat routers that need to forward a &lt;strong&gt;lot&lt;/strong&gt; of traffic in hardware at line rate).&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s all nice, but what does this have to do with traffic reflection?  How can we make some endpoint forward on traffic to our target?&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ll preface this &lt;em&gt;again&lt;/em&gt; by saying this is thus far just theoretical, and still needs to be labbed up to test it out.  This is very much a hypothesis of &amp;ldquo;If GRE could be reflected, could this be a possible way?&amp;rdquo; rather than a statement that &amp;ldquo;GRE can be reflected, and this is how&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Now, we may sometimes still want to figure out if the other end of a GRE tunnel is alive and that the tunnel is &amp;ldquo;up&amp;rdquo;, but there is no keepalive mechanism in the GRE spec.  So, how do we do that?  Well, Cisco, $deity bless &amp;lsquo;em, never could pass up an opportunity to invent protocols where there is a dirth of RFC coverage, and so GRE keepalives are born.&lt;/p&gt;

&lt;p&gt;GRE keepalives effectively trick the remote router into forwarding the keepalive packet &lt;em&gt;back&lt;/em&gt; to the sender, all without having to know anything about keepalives itself.  Let&amp;rsquo;s say &lt;code&gt;RouterA&lt;/code&gt; is the one sending keepalives, and &lt;code&gt;RouterB&lt;/code&gt; is the other end of the GRE tunnel.&lt;/p&gt;

&lt;p&gt;When &lt;code&gt;RouterA&lt;/code&gt; usually sends traffic through the GRE tunnel, it will take the original packet of user or transit traffic and stuff an additional IP and GRE header onto it.  There are some additional fields available in the GRE header, but effectively it&amp;rsquo;s damn near nothing and just says &amp;lsquo;the actual inner packet is &lt;em&gt;this&lt;/em&gt; protocol&amp;rsquo;.  That will generally by IPv4 (0x0800) or IPv6 (0x86dd), but really can be any EtherType.  The new IP header has a source IP set to &lt;code&gt;RouterA&lt;/code&gt;&amp;rsquo;s own IP address and a destination IP set to &lt;code&gt;RouterB&lt;/code&gt;&amp;rsquo;s IP address.  The original user traffic would have looked like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; -----------------------------------------------------
| IP | SRC IP          | DST             | IP PAYLOAD |
|    | 2001:db8:5::100 | 2001:db8:6::200 |            |
 -----------------------------------------------------
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With the additional GRE and IP header added, the encapsulated packet looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; ----------------------------------------------------------------------------------------------------------------
| IP | SRC IP        | DST IP        | GRE | GRE           | IP | SRC IP          | DST             | IP PAYLOAD |
|    | 2001:db8:1::1 | 2001:db8:2::2 |     | PROTOCOL=08dd |    | 2001:db8:5::100 | 2001:db8:6::200 |            |
 ----------------------------------------------------------------------------------------------------------------
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Great!  So the GRE packet gets over to &lt;code&gt;RouterB&lt;/code&gt;, it sees its own IP address as the destination and realizes that it has to do something with this packet rather than forward it on.  The L4 protocol is 47 (GRE), so if it can handle GRE then it realizes it has to check what protocol is next in the stack (e.g. IPv4 as 0x0800 or IPv6 as 0x08dd as described above), strip the GRE header, and then forward the inner packet on its merry way (provided it has a route for the destination, the TTL isn&amp;rsquo;t expired, etc. etc.).&lt;/p&gt;

&lt;p&gt;So how does &lt;code&gt;RouterA&lt;/code&gt; get &lt;code&gt;RouterB&lt;/code&gt; to forward keepalives back to &lt;code&gt;RouterA&lt;/code&gt;, especially as we said that &lt;code&gt;RouterB&lt;/code&gt; doesn&amp;rsquo;t know anything about dem dere fancy GRE keepalives?&lt;/p&gt;

&lt;p&gt;&lt;code&gt;RouterA&lt;/code&gt; actually encapsulates its keepalive packet in GRE &lt;strong&gt;twice&lt;/strong&gt;.  The outer headers are what we&amp;rsquo;ve discussed here already:  source = &lt;code&gt;RouterA&lt;/code&gt; IP, destination = &lt;code&gt;RouterB&lt;/code&gt; IP, and then a GRE header.  The inner packet in this case is not some user traffic that&amp;rsquo;s going to the networks at &lt;code&gt;RouterB&lt;/code&gt;, but rather &lt;strong&gt;another GRE packet&lt;/strong&gt;.  &lt;code&gt;RouterA&lt;/code&gt; crafts the packet so that the source IP on this &lt;em&gt;inner&lt;/em&gt; GRE packet is actually &lt;em&gt;&lt;code&gt;RouterB&lt;/code&gt;&lt;/em&gt;&amp;rsquo;s IP address, with the destination set to &lt;em&gt;its own&lt;/em&gt; IP address (that is, &lt;code&gt;RouterA&lt;/code&gt;&amp;rsquo;s IP).  That header stack looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; --------------------------------------------------------------------------------------------------------------------
| IP | SRC IP        | DST IP        | GRE | GRE             | IP | SRC IP        | DST IP        | GRE | GRE        |
|    | 2001:db8:1::1 | 2001:db8:2::2 |     | PROTOCOL=0x08dd |    | 2001:db8:2::2 | 2001:db8:1::1 |     | PROTOCOL=0 |
 --------------------------------------------------------------------------------------------------------------------
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For this double-encapsulated packet, things at &lt;code&gt;RouterB&lt;/code&gt; start off just as described above for regular user traffic.  &lt;code&gt;RouterB&lt;/code&gt; receives the GRE packet, sees the destination IP is its own, checks the GRE header for the protocol number value and then strips it, and then starts to look at what it should do with the inner payload.  Except now, that inner payload is &lt;em&gt;another&lt;/em&gt; GRE packet, with a source IP address set to &lt;code&gt;RouterB&lt;/code&gt;&amp;rsquo;s own IP and a destination IP set to &lt;code&gt;RouterA&lt;/code&gt;&amp;rsquo;s IP.&lt;/p&gt;

&lt;p&gt;So what does &lt;code&gt;RouterB&lt;/code&gt; do?  Well, like a good router, it looks up its route for &lt;code&gt;RouterA&lt;/code&gt; and dutifully forwards the packet (with the outer IP and GRE header stripped) back over to thattaway.  &lt;code&gt;RouterA&lt;/code&gt; receives the packet, sees its own IP address as the destination, sees a GRE header, and evaluates that.  GRE keepalives use a special protocol number of 0 (as opposed to 0x0800 or x08dd for IPv4 and IPv6 as mentioned above).  On seeing the protocol field set to 0, &lt;code&gt;RouterA&lt;/code&gt; realizes this is a GRE keepalive packet, and it resets the GRE tunnel keepalive counter to zero and considers the GRE tunnel to be up.&lt;/p&gt;

&lt;h3 id=&#34;so-how-would-this-be-reflected&#34;&gt;So how would this be reflected?&lt;/h3&gt;

&lt;p&gt;Who says the attacker has to set the destination IP address in the inner GRE packet to their own address?&lt;/p&gt;

&lt;p&gt;The very &lt;em&gt;design&lt;/em&gt; of this is such that &lt;code&gt;RouterB&lt;/code&gt; in our example does not need to know anything about keepalives or the double encapsulation setup.  It does no correlation or checks between the source and destination IP addresses on the outer IP header and the inner ones.  There is nothing stopping me from setting the destination address to whatever the hell I want.  If I want to hit someone at 2001:db8:ffff::a, I just do:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; -----------------------------------------------------------------------------------------------------------------------
| IP | SRC IP        | DST IP        | GRE | GRE             | IP | SRC IP        | DST IP           | GRE | GRE        |
|    | 2001:db8:1::1 | 2001:db8:2::2 |     | PROTOCOL=0x08dd |    | 2001:db8:2::2 | 2001:db8:ffff::a |     | PROTOCOL=0 |
 -----------------------------------------------------------------------------------------------------------------------
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To think of it: What&amp;rsquo;s stopping me from stuffing a whole IP packet in there rather than just a minimal-payload GRE keepalive?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; --------------------------------------------------------------------------------------------------------------------------------------
| IP | SRC IP        | DST IP        | GRE | GRE             | IP | SRC IP        | DST IP           | GRE | GRE             | IPv6    |
|    | 2001:db8:1::1 | 2001:db8:2::2 |     | PROTOCOL=0x08dd |    | 2001:db8:2::2 | 2001:db8:ffff::a |     | PROTOCOL=0x08dd | PAYLOAD |
 --------------------------------------------------------------------------------------------------------------------------------------
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I see two possible permutations of this, with varying levels of difficulty and probability of execution:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;1.&lt;/code&gt; Targeted to configured GRE tunnels, with source address spoofing&lt;/p&gt;

&lt;p&gt;Routers processing GRE traffic &lt;em&gt;should&lt;/em&gt; generally first check if they have a tunnel configured with matching source and destination IPs.  If I&amp;rsquo;m &lt;code&gt;RouterB&lt;/code&gt;, I should first check that I have a GRE tunnel configured towards &lt;code&gt;RouterA&lt;/code&gt;&amp;rsquo;s IP before I process GRE packets with source IPs of &lt;code&gt;RouterA&lt;/code&gt; destined for me.  Provided routers are doing that correctly, this means an attack would have to (a) know about (or guess / scan for) configured GRE tunnels on potential reflectors in order to pull this off and (b) successfully spoof &lt;code&gt;RouterA&lt;/code&gt;&amp;rsquo;s source IP.&lt;/p&gt;

&lt;p&gt;A search could theoretically be possible by sending a GRE-encapsulated packet towards &lt;code&gt;RouterB&lt;/code&gt; with an IP payload destined for an IP that the attacker controls, with the source IP on the outer IP header being varied as the IPs being tested.  The attacker could then listen for that payload packet, and if received, confirm that the tested source IP does in fact have a GRE tunnel configured with &lt;code&gt;RouterB&lt;/code&gt;.  This is a massive search space, though, as each potential reflector would need to be tested against each other potential source IP on the public Internet.  Even in the IPv4 Internet, this is huge, as you&amp;rsquo;re dealing with &lt;code&gt;(2**32) * (2**32 - 1)&lt;/code&gt; combinations (minus RFC1918, multicast, documentation, and other reserved ranges).  That&amp;rsquo;s 18,446,744,069,414,584,320 combinations, for those keeping score at home.  Unless the attackers have prior knowledge about potential reflectors and configured GRE tunnels, this possibility is somewhat remote.&lt;/p&gt;

&lt;p&gt;Second to that, this requires that the attacker be able to spoof &lt;code&gt;RouterA&lt;/code&gt;&amp;rsquo;s IP address.  This is less of a problem given that networks that fail to &lt;a href=&#34;http://www.bcp38.info/index.php/Main_Page&#34;&gt;implement&lt;/a&gt; &lt;a href=&#34;https://tools.ietf.org/html/bcp38&#34;&gt;BCP38&lt;/a&gt; seem to be plentiful, as we see from the prevalance of reflected traffic we have because of spoofed sources.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;2.&lt;/code&gt;  To any GRE-capable router, but dependent on GRE-processing flaw&lt;/p&gt;

&lt;p&gt;GRE has not yet been subjected to the same scrutiny as e.g. DNS and NTP following those becoming heavily abused in reflected and amplified DDoS attacks (how I do not miss the &lt;a href=&#34;https://blog.cloudflare.com/technical-details-behind-a-400gbps-ntp-amplification-ddos-attack/&#34;&gt;Christmas of 2013&lt;/a&gt;&amp;hellip;).  A hypothetical laxity in the processing of GRE traffic could potentially make this a &lt;em&gt;much&lt;/em&gt; easier vector to exploit for reflection while simultaneously being &lt;em&gt;very&lt;/em&gt; difficult for origin and reflector networks to combat.&lt;/p&gt;

&lt;p&gt;If &lt;code&gt;RouterB&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; validate that it has a GRE tunnel configured with the source IP of the GRE packet, the attacker could send a GRE packet to &lt;code&gt;RouterB&lt;/code&gt; &lt;em&gt;simply from his own IP address or any other IP they want&lt;/em&gt; and still have &lt;code&gt;RouterB&lt;/code&gt; process the GRE packet, strip the header, and pass on the inner packet to the target.  This &lt;em&gt;drastically&lt;/em&gt; reduces the search space on the IPv4 Internet from 18,446,744,069,414,584,320 down to &lt;code&gt;2**32&lt;/code&gt; or roughly 4 billion.  It also means the attacker &lt;em&gt;does not even need to spoof the target&amp;rsquo;s IP address&lt;/em&gt; in order to pull of the reflection attack, as the target IP is contained &lt;em&gt;within&lt;/em&gt; the encapsulated packet.  They can opt to spoof their source IP if they have access to a network that does not implement BCP38, but this would be an optional step that provides additional obfuscation and shielding from attribution and traceback.&lt;/p&gt;

&lt;p&gt;What would make this difficult to combat on the service provider side is that, should such a GRE processing flaw exist, this could be pulled of without any address spoofing, so even networks that properly implement BCP38 would let it pass.  GRE also has perfectly legitimate uses on business and residential networks and so any transiting or hosting networks for the attacker and reflector likely would not be able to simply drop the offending traffic.  Fixes would be dependent on either ACLs or firmware updates on the reflectors.&lt;/p&gt;

&lt;p&gt;The chances of this second reflection option are somewhat remote, as having a flaw of this nature could potentially result in a serious NAT traversal flaw as well.  If I can send &lt;code&gt;RouterB&lt;/code&gt; a GRE-encapsulated packet from any source and have it forward the inner packet along provided it has &lt;em&gt;any&lt;/em&gt; GRE configured it on, that could smash through NAT.&lt;/p&gt;

&lt;h3 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;This post was largely the result of spitballing how reflection might be possible with GRE traffic in light of the recent spike of GRE in large, volumetric DDoS attacks.  There is no amplification in this, and if anything the attacker needs to send &lt;em&gt;more&lt;/em&gt; data than reaches the target as they send the payload with 2x GRE/IP header stacks whereas the reflector strips the outer IP &amp;amp; GRE headers and just sends the one, but should it prove possible it could still be useful for obfuscation.&lt;/p&gt;

&lt;p&gt;On the plus side, While DDoS targets/victims with complex networks or applications may not be able to drop GRE entirely, simpler targets (e.g. websites) should be able to simply drop any IP protocol 47 (GRE) traffic destined for the site without impact.  Given the traffic volumes we&amp;rsquo;re seeing, that&amp;rsquo;s pretty much completely contingent on having a large scale DDoS scrubbing service in place, but at least the rulesets should be fairly simple provided there aren&amp;rsquo;t actual production GRE tunnels or e.g. PPTP VPNs (&lt;a href=&#34;https://www.schneier.com/academic/pptp/faq.html&#34;&gt;for shame&lt;/a&gt;!) hiding behind the scrubbing service.  If needed, static GRE tunnels should be easier to pin down in rulesets with specific source and destinations IPs than PPTP VPNs that use GRE and have varied source IPs.&lt;/p&gt;

&lt;p&gt;P.S. If this hyptothetical flaw in processing of GRE&amp;rsquo;d traffic &lt;em&gt;does&lt;/em&gt; end up being a thing, I call dibs on the &amp;ldquo;pick a trendy and somewhat obnoxious name for software flaws&amp;rdquo; rights and dub this &lt;strong&gt;GREflector&lt;/strong&gt;!&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>