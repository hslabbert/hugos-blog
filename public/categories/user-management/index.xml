<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>User Management on Hugo&#39;s Blog</title>
    <link>http://blog.slabnet.com/categories/user-management/</link>
    <description>Recent content in User Management on Hugo&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>hugo@slabnet.com (Hugo Slabbert)</managingEditor>
    <webMaster>hugo@slabnet.com (Hugo Slabbert)</webMaster>
    <copyright>&amp;copy; 2016 Hugo Slabbert</copyright>
    <lastBuildDate>Tue, 25 Mar 2008 05:28:20 +0000</lastBuildDate>
    <atom:link href="http://blog.slabnet.com/categories/user-management/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Find Disabled and Inactive User and Computer Accounts using Powershell - Part II</title>
      <link>http://blog.slabnet.com/post/find-disabled-and-inactive-user-and-computer-accounts-using-powershell-part2/</link>
      <pubDate>Tue, 25 Mar 2008 05:28:20 +0000</pubDate>
      <author>hugo@slabnet.com (Hugo Slabbert)</author>
      <guid>http://blog.slabnet.com/post/find-disabled-and-inactive-user-and-computer-accounts-using-powershell-part2/</guid>
      <description>&lt;p&gt;Part I demonstrated how to find aged or inactive accounts, and in Part II we will look at another lingering account type: disabled accounts.&lt;/p&gt;

&lt;p&gt;Like inactive accounts, Directory Searchers also come in handy for disabled accounts. We can also, however, read an Active Directory account&amp;rsquo;s status directly from a hidden attribute on the ADSI object. Let&amp;rsquo;s start with the Directory Searcher method. This entry also draws from &lt;a href=&#34;http://blogs.technet.com/bahramr/archive/2008/01/25/powershell-script-to-disable-inactive-accounts-in-active-directory.aspx&#34;&gt;Bahram’s Blog&lt;/a&gt;. The code:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$adobjroot = [adsi]&#39;&#39;
$objdisabsearcher = New-Object System.DirectoryServices.DirectorySearcher($adobjroot)
$objdisabsearcher.filter = &amp;quot;(&amp;amp;(objectCategory=person)(objectClass=user)(userAccountControl:1.2.840.113556.1.4.803:=2))&amp;quot;
$resultdisabaccn = $objdisabsearcher.findall() | sort path&lt;/code&gt;&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;That was a lot easier! The &lt;code&gt;$adobjroot&lt;/code&gt; line gives us an ADSI object for the root of our domain. The second line creates a new Directory Services searcher, and then we add our filter.&lt;/p&gt;

&lt;p&gt;As with Part I, setting objectCategory to &lt;code&gt;person&lt;/code&gt; and objectClass to &lt;code&gt;user&lt;/code&gt; sets up our filter to search for user accounts; switch both of those to &lt;code&gt;computer&lt;/code&gt; to search for computer accounts instead.&lt;/p&gt;

&lt;p&gt;The userAccountControl portion is a bit of weird number, though, isn&amp;rsquo;t it?! After some digging, I was able to determine that the &lt;code&gt;:1.2.840.113556.1.4.803:&lt;/code&gt; is the attribute ID for the Last-Logon-Timestamp Attribute (found on an &lt;a href=&#34;http://msdn2.microsoft.com/en-us/library/ms676824.aspx&#34;&gt;MSDN article&lt;/a&gt; linked from &lt;a href=&#34;http://blogs.technet.com/bahramr/archive/2008/01/25/powershell-script-to-disable-inactive-accounts-in-active-directory.aspx&#34;&gt;Bahram&amp;rsquo;s Blog&lt;/a&gt;). Specifying that value in the directory searcher filter queries for the value of that specific attribute stored in the userAccountControl property, rather than userAccountControl as a whole. Stephen Looney actually corrected this for me, as I was somewhat off the mark in my deduction. The string is not a selection filter, as I had supposed, but more akin to a bitwise OR operator. See his comment below for clarification.&lt;/p&gt;

&lt;p&gt;The last line of the code simply collects our searcher results in System.DirectoryServices.SearchResult collection&lt;/p&gt;

&lt;p&gt;The alternative method to determine an account&amp;rsquo;s status is to check a hidden attribute on the ADSI object itself. For this you will need the Distinguished Name of a user or computer account:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$struserdn = &amp;quot;CN=Some User,OU=Users,OU=Corp,DC=yourdomain,DC=com&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Set up an ADSI object for that account:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$adobjuser = [ADSI]&amp;quot;LDAP://$struserdn&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;And access the hidden method:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$adobjuser.PsBase.InvokeGet(&amp;quot;AccountDisabled&amp;quot;)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;This will return $true if the account is disabled, and $false if the account is not disabled (i.e. it is enabled). It&amp;rsquo;s not as glamorous as the directory searcher method, but I think both have their place.&lt;/p&gt;

&lt;p&gt;Also, feel free to play around with the lastLogonTimeStamp and UserAccountControl attributes in the directory searcher. For instance, to find only disabled accounts that have been inactive for a certain number of days, you could use an LDAP string like:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$objsearcher.filter =&lt;/code&gt;&lt;code&gt;(&amp;amp;(objectCategory=person)(objectClass=user)(userAccountControl:1.2.840.113556.1.4.803:=2)&lt;/code&gt;&lt;code&gt;(lastLogonTimeStamp&amp;lt;=&amp;quot; + $lltIntLimit + &amp;quot;)&lt;/code&gt;&lt;code&gt;)&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Or switch it up for only enabled accounts inactive for a certain period by flipping the userAccountControl portion around be negative:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$objsearcher.filter =&lt;/code&gt;&lt;code&gt;(&amp;amp;(objectCategory=person)(objectClass=user)(!(userAccountControl:1.2.840.113556.1.4.803:=2)&lt;/code&gt;&lt;code&gt;)(lastLogonTimeStamp&amp;lt;=&amp;quot; + $lltIntLimit + &amp;quot;)&lt;/code&gt;&lt;code&gt;)&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;I hope this has been helpful. As always, comments, corrections, additions, or questions are appreciated.&lt;/p&gt;

&lt;p&gt;Bitcoin tip address for this post: 192yT6362K6BgLpm8B2xhcCVZtrnwQkjek&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Find Disabled and Inactive User and Computer Accounts using Powershell - Part I</title>
      <link>http://blog.slabnet.com/post/find-disabled-and-inactive-user-and-computer-accounts-using-powershell-part1/</link>
      <pubDate>Tue, 25 Mar 2008 05:28:15 +0000</pubDate>
      <author>hugo@slabnet.com (Hugo Slabbert)</author>
      <guid>http://blog.slabnet.com/post/find-disabled-and-inactive-user-and-computer-accounts-using-powershell-part1/</guid>
      <description>&lt;p&gt;We&amp;rsquo;ll start off with Inactive accounts first, and then work on the disabled accounts after that.&lt;/p&gt;

&lt;p&gt;Active Directory in Server 2003 has a nice user/computer attribute called lastLogonTimeStamp that can help us keep track of inactive accounts. If you have ever tried to use that attribute, however, you might have come up with something like this&amp;hellip;&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;&lt;code&gt;PoSH&amp;gt; $struserdn = &amp;quot;CN=Some User,OU=Users,OU=Corp,DC=yourdomain,DC=local&amp;quot;
PoSH&amp;gt; $adobjuser = [ADSI]&amp;quot;LDAP://$struserdn&amp;quot;
PoSH&amp;gt; $adobjuser
{CN=Some User,OU=Users,OU=Corp,DC=yourdomain,DC=local}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;PoSH&amp;gt; $adobjuser.lastLogonTimetamp&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;PoSH&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;What the &amp;hellip;? Hmm&amp;hellip;I&amp;rsquo;m sure I saw lastLogonTimestamp in the members for that object before:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;PoSH&amp;gt;$adobjuser | Get-Member&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;TypeName: System.DirectoryServices.DirectoryEntry
...
lastLogonTimestamp              Property   System.DirectoryServices.PropertyValueCollection lastLogonTimestamp {get;...
...
&lt;/code&gt;
&lt;code&gt;PoSH&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Right,  like I said! Then why doesn&amp;rsquo;t it give me any information for that property? May it&amp;rsquo;s blank? Highly unlikely, but let&amp;rsquo;s check:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;PoSH&amp;gt; $adobjuser | Format-List *
...
lastLogonTimestamp              : {System.__ComObject}
...&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;PoSH&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Great! What do I do with that thing? To be honest, working with ComObjects is not really my thing, but we still can get the information we want. For my purposes, I was searching through AD with a DirectorySearcher anyway, and the answer to my problems came from DirectorySearcher in the end. First, the code (credit to &lt;a href=&#34;http://blogs.technet.com/bahramr/archive/2008/01/25/powershell-script-to-disable-inactive-accounts-in-active-directory.aspx&#34;&gt;Bahram&amp;rsquo;s Blog&lt;/a&gt;), and then we&amp;rsquo;ll run through what we&amp;rsquo;re actually doing.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$currentDate = [System.DateTime]::Now
$currentDateUtc = $currentDate.ToUniversalTime()
&lt;/code&gt;&lt;code&gt;$lltstamplimit = $currentDateUtc.AddDays(- $NumDays)
$lltIntLimit = $lltstampLimit.ToFileTime()
$adobjroot = [adsi]&#39;&#39;
&lt;/code&gt;&lt;code&gt;$objstalesearcher = New-Object System.DirectoryServices.DirectorySearcher($adobjroot)
&lt;/code&gt;&lt;code&gt;$objstalesearcher.filter = &amp;quot;(&amp;amp;(objectCategory=person)(objectClass=user)(lastLogonTimeStamp&amp;lt;=&amp;quot; + $lltIntLimit + &amp;quot;))&amp;quot;
&lt;/code&gt;&lt;code&gt;$resultstaleaccn = $objstalesearcher.findall() | sort path&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Alright, so before we get going, this snippet of code requires that we define an Int32 variable called &lt;code&gt;$numdays&lt;/code&gt; before we run it. This will be used as the number of days since the account last logged on. So what exactly is going on here? The easiest way to both get a proper DateTime object and get a relative time for setting the period for inactive accounts is to get the current date and time:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$currentDate = [System.DateTime]::Now&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;As far as I can see, you could also use &lt;code&gt;$currentdate = Get-Time&lt;/code&gt; , so it&amp;rsquo;s your choice, really.&lt;/p&gt;

&lt;p&gt;Active Directory stores times in UTC format, so we can use the ToUniversalTime() method available on the System.DateTime class:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$currentDateUtc = $currentDate.ToUniversalTime()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;This is where the &lt;code&gt;$numdays&lt;/code&gt; variable comes in. Let&amp;rsquo;s say your organization has a policy in effect that accounts that have been inactive for 60 must be disabled. If the lastLogonTimeStamp attribute is 60 days less than the current Date/Time, then we know that account has not been logged onto for the last 60 days. So, we will want to search for accounts that have a value 60 days less than today in their lastLogonTimeStamp attribute. To make that reference point, we can do some simple math:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$lltstamplimit = $currentDateUtc.AddDays(- $NumDays)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;This assumes that we have run &lt;code&gt;$NumDays = 60&lt;/code&gt; somewhere before this last command, and effectively saves our last logon time stamp limit ($lltstamplimit) as a System.DateTime value 60 days before now.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$lltIntLimit = $lltstampLimit.ToFileTime()&lt;/code&gt; converts the &lt;code&gt;$lltstamplimit&lt;/code&gt; to an Int64 value. Why? You&amp;rsquo;ve got me! Please let me know if you have the goods on this, because I&amp;rsquo;m still blissfully unaware of the purpose/function of Int64 values.&lt;/p&gt;

&lt;p&gt;The rest is fairly straight-forward. We set up a directory searcher and define the filter as a user object the lastLogonTimeStamp less than the limit we defined in &lt;code&gt;$lltIntLimit&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$adobjroot = [adsi]&#39;&#39;
$objstalesearcher = New-Object System.DirectoryServices.DirectorySearcher($adobjroot)
$objstalesearcher.filter = &amp;quot;(&amp;amp;(objectCategory=person)(objectClass=user)(lastLogonTimeStamp&amp;lt;=&amp;quot; + $lltIntLimit + &amp;quot;))&amp;quot;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;In the name of tidiness and efficiency, I would recommend restricting the search root to your user containers with something like &lt;code&gt;$objstalesearcher.searchroot = &amp;quot;LDAP://$searchrootdn&amp;quot;&lt;/code&gt; where $searchrootdn is a distinguished name as a string.&lt;/p&gt;

&lt;p&gt;All that remains at that point is to collect the results:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$resultstaleaccn = $objstalesearcher.findall() | sort path&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;For my own purposes I sort the results by their LDAP path, but you obviously don&amp;rsquo;t have to. Remember that your result will be saved as a System.DirectoryServices.SearchResult object, so you will probably have to use &lt;code&gt;$_.Properties.[SomeProperty]&lt;/code&gt; to get the information you&amp;rsquo;re looking for.  From there, you can do with the results as you please.&lt;/p&gt;

&lt;p&gt;Oh, and if you&amp;rsquo;re looking for inactive computer  accounts instead of user accounts, switch both the objectCategory and objectClass values in your DS searcher filter to &lt;em&gt;computer.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;To learn how to find &lt;em&gt;disabled&lt;/em&gt; accounts rather than inactive ones, head over to Part II.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>